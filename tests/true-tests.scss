@import '../bower_components/true/sass/_true';
@import '../scss/_sassdash';

$true-terminal-output: true;

$test-falsey: ('', 0, false, null);
$test-empty-list: ();

@function test-add($x, $y, $args...) {
    @return $x + $y;
}

@function test-square($n, $args...) {
    @return $n * $n;
}

@function test-double($n, $args...) {
  @return $n * 2;
}

@function test-fixed($n) {
    @return __number-to-fixed($n);
}

@function test-is-even($n, $args...) {
    @return $n % 2 == 0;
}

@function test-floor($n, $args...) {
  @return floor($n);
}

@function test-args($args...) {
  @return $args;
}

@function test-lists-equal($one, $two) {
  @if type-of($one) == number and type-of($two) == number {
    @return $one == $two and unit($one) == unit($two);
  } @else if (type-of($one) == list or type-of($one) == arglist)
        and (type-of($two) == list or type-of($two) == arglist) {
    $equal: length($one) == length($two);
    $index: 1;

    @while ($index <= max(length($one), length($two)) and $equal) {
      $equal: test-lists-equal(nth($one, $index), nth($two, $index));
      $index: $index + 1;
    }

    @return $equal;
  } @else {
    @return $one == $two;
  }
}


@mixin test-group() { @content; }

@mixin xit($args...) { @if false { @content; } }


@include test-module('sassdash _after') {
    @include test('should create a function that invokes func after n calls') {
        $test-after: __after(5, length);

        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));

        @include assert-equal($result, 2);

        $test-after: __after(5, length);

        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));

        @include assert-equal($result, null);

        $test-after: __after(0, length);

        $result: __call($test-after, null, (1, 2));

        @include assert-equal($result, 2);
    }

    @include test('should allow func as the first argument') {
        $test-after: __after(length, 0);

        $result: __call($test-after, null, (1, 2));

        @include assert-equal($result, 2);
    }
}

@function test-ary-1($a, $b: 0, $c: 0) {
    @return $a + $b + $c;
}
@function test-ary-2($a) {
    @return $a * 3;
}
@include test-module('_ary') {
    @include test('should cap the number of params provided to function') {
        $actual: _map('6' '8' '10', _ary(_parse-int, 1));

        @include assert-equal($actual, 6 8 10);
    }

    @include test('should default to n = 1') {
        $actual: _map('6' '8' '10', _ary(_parse-int));

        @include assert-equal($actual, 6 8 10);
    }

    @include test('should work when provided less than the capped number of arguments') {
        $capped: _ary(test-ary-1, 3);

        @include assert-equal(_exec($capped, 7), 7);
    }

    @include test('should work as an iteratee for _map') {
        $funcs: _map(test-ary-1 test-ary-2, _ary);

        @include assert-equal(_exec(nth($funcs, 1), 7), 7);
        @include assert-equal(_exec(nth($funcs, 2), 7), 21);
    }
}

@function test-assign-1($a, $b) {
    @return if($a == null, $b, $a);
}
@include test-module('_assign') {
    @include test('should assign properties of a source object to the destination object') {
        @include assert-equal(_assign(('a': 1), ('b': 2)), ('a': 1, 'b': 2));
    }

    @include test('should accept multiple source objects') {
        $expected: ('a': 1, 'b': 2, 'c': 3);

        @include assert-equal(_assign(('a': 1), ('b': 2), ('c': 3)), $expected);
        @include assert-equal(_assign(('a': 1), ('b': 2, 'c': 2), ('c': 3)), $expected);
    }

    @include test('should overwrite destination properties') {
        $expected: ('a': 3, 'b': 2, 'c': 1);

        @include assert-equal(_assign(('a': 1, 'b': 2), $expected), $expected);
    }

    @include xit('should work with a customizer callback') {
        $actual: _assign(('a': 1, 'b': 2), ('a': 3, 'c': 3), test-assign-1);
        $expected: ('a': 1, 'b': 2, 'c': 3);

        @include assert-equal($actual, $expected);
    }

    @include xit('should work with a customizer that returns undefined') {
        $expected: ('a': $__undefined__);
        @include assert-equal(_assign((), $expected, _identity), $expected);
    }
}

@include test-module('_at') {
    $list: ('a', 'b', 'c');
    $map-list: __to-map($list);
    $empty-list: ();

    $map-list: __set($map-list, 1.1, 1);

    @include test('should return the elements corresponding to the specified keys') {
        $actual: _at($list, (1 3));
        @include assert-equal($actual, ('a' 'c'));
    }

    @include test('should return null for nonexistent keys') {
        $actual: _at($list, (3 5 1));
        @include assert-true(test-lists-equal($actual, ('c', null, 'a')));
    }

    @include test('should return an empty list when no keys are provided') {
        @include assert-equal(_at($list), $empty-list);
        @include assert-equal(_at($list, (), ()), $empty-list);
    }

    @include test('should accept multiple key arguments') {
        $actual: _at(('a' 'b' 'c' 'd'), 4, 1, 3);

        @include assert-equal($actual, 'd' 'a' 'c');
    }

    @include xit('should work with a falsey collection argument when keys are provided') {}

    @include xit('should work with an arguments object for collection') {}

    @include test('should work with an object for collection') {
        $actual: _at(('a': 1, 'b': 2, 'c': 3), ('c' 'a'));
        
        @include assert-equal($actual, 3 1);
    }

    @include xit('should pluck inherited property values') {}

    @include test('should work with a string literal for collection') {
        @include assert-equal(_at('abc', 3 1), 'c' 'a');
    }
}

$test-before-count: 0 !global;
@function test-before-1() {
    $test-before-count: $test-before-count + 1 !global;

    @return $test-before-count;
}
@include test-module('_before') {
    @include test('should create a function that invokes func after n calls') {
        // before(n) should invoke `func` before being called `n` times
        $test-before-count: 0 !global;
        $test-before: _before(5, test-before-1);

        $_: _call($test-before);
        $_: _call($test-before);
        $_: _call($test-before);
        $_: _call($test-before);

        @include assert-equal($test-before-count, 4);

        // before(n) should not invoke `func` after being called `n - 1` times
        $test-before-count: 0 !global;
        $test-before: _before(5, test-before-1);

        $_: _call($test-before);
        $_: _call($test-before);
        $_: _call($test-before);
        $_: _call($test-before);
        $_: _call($test-before);
        $_: _call($test-before);

        @include assert-equal($test-before-count, 4);
        
        // before(0) should not invoke `func` immediately
        $test-before-count: 0 !global;
        $test-before: _before(0, test-before-1);

        @include assert-equal($test-before-count, 0);

        // before(0) should not invoke `func` when called
        $test-before-count: 0 !global;
        $test-before: _before(0, test-before-1);

        $_: _call($test-before);

        @include assert-equal($test-before-count, 0);
    }

    @include xit('should coerce non-finite n values to 0') {}

    @include test('should allow func as the first argument') {
        $test-before-count: 0 !global;

        $test-before: _before(test-before-1, 2);

        $_: _call($test-before);
        $_: _call($test-before);

        @include assert-equal($test-before-count, 1);
    }

    @include xit('should not set a this binding') {}
}

@function test-bind-1($value) {
    $foo: __this('foo');
    @return $foo + $value;
}
@function test-bind-2($value) {
    @return $value;
}
@function test-bind-3($greeting, $punc) {
    @return $greeting + ' ' + __this('user') + $punc;
}
@include test-module('_bind') {
    @include test('should bind a function to a scope') {
        $_: __scope(('foo': 1));
        $func: _bind(test-bind-1);
        $_: __scope(false);

        @include assert-equal(_exec($func, 3), 4);
    }

    @include test('should bind a function to a map') {
        $_: __scope();
        $func: _bind(test-bind-1, ('foo': 2));
        $_: __scope(false);

        @include assert-equal(_exec($func, 3), 5);
    }

    @include test('should accept a falsey this-arg argument') {
        @each $value in $test-falsey {
            $func: _bind(test-bind-2, $value);

            @include assert-equal(_exec($func, 1), 1);
        }
    }

    @include test('should partially apply arguments') {
        $scope: __scope(('user': 'fred'));
        $scope-id: __get($scope, '_id');
        $func: _bind(test-bind-3, $scope-id, 'hi');
        $_: __scope(false);

        @include assert-equal(_exec($func, '!'), 'hi fred!');
    }

    @include xit('should support placeholders') {} // todo

    @include test('should ensure new bound is an executable function') {
        $func: _bind(test-bind-3, ('foo': 'bar'));

        @include assert-true(_is-function($func));
    }
}

@include test-module('case methods') {
    $strings: (
        'foo bar', 'Foo bar', 'foo Bar', 'Foo Bar',
        'fooBar', '--foo-bar', '__foo_bar__'
    );

    $converted: (
        'camel': 'fooBar',
        'kebab': 'foo-bar',
        'snake': 'foo_bar',
        'start': 'Foo Bar'
    );

    @each $case-name in ('camel' 'kebab' 'snake' 'start') {
        $method-name: '_' + $case-name + '-case';
        
        @include test('should convert string to #{$case-name} case') {
            @each $string in $strings {
                $actual: call($method-name, $string);
                $expected: if($case-name == 'start' and $string == 'FOO BAR', $string, __get($converted, $case-name));

                @include assert-equal($actual, $expected);
            }
        }

        @include test('#{$method-name} should handle double-converting strings') {
            @each $string in $strings {
                $actual: call($method-name, call($method-name, $string));
                $expected: if($case-name == 'start' and $string == 'FOO BAR', $string, __get($converted, $case-name));

                @include assert-equal($actual, $expected);
            }
        }

        @include test('#{$method-name} should return an unwrapped value when chaining') {
            $actual: _('foo bar', $case-name + '-case');
            $expected: __get($converted, $case-name);

            @include assert-equal($actual, $expected);
        }
    }
}

@include test-module('_capitalize') {
    @include test('should capitalize the first character of a string') {
        @include assert-equal(_capitalize('fred'), 'Fred');
        @include assert-equal(_capitalize('Fred'), 'Fred');
        @include assert-equal(_capitalize(' fred'), ' fred');
    }

    @include test('should return an unwrapped value when chaining') {
        @include assert-equal(_('fred', capitalize), 'Fred');
    }
}

@include test-module('_chunk') {
    $list: (0 1 2 3 4 5);

    @include test('should return chunked arrays') {
        $actual: _chunk($list, 3);
        $expected: ((0 1 2) (3 4 5));

        @include assert-equal($actual, $expected);
    }

    @include test('should return the last chunk as remaining elements') {
        $actual: _chunk($list, 4);
        $expected: ((0 1 2 3) (4 5));

        @include assert-equal($actual, $expected);
    }

    @include test('should ensure the minimum chunkSize is one') {
        @each $value in append($test-falsey, -1) {        
            $actual: _chunk($list, $value);
            $expected: (0,) (1,) (2,) (3,) (4,) (5,);

            @include assert-true(test-lists-equal($actual, $expected));
        }
    }

    @include test('should work as an iteratee for _map') {
        $actual: _map(((1 2) (3 4)), _chunk);
        $expected: (((1,) (2,)) ((3,) (4,)));

        @include assert-true(test-lists-equal($actual, $expected));
    }
}

@include test-module('_compact') {
    @include test('should filter falsey values') {
        $list: join('0' '1' '2', $test-falsey);
        $actual: _compact($list);
        $expected: ('0' '1' '2');

        @include assert-equal($actual, $expected);
    }

    @include xit('should return a wrapped value when chaining') {}

    @include test('should work when in between lazy operators') {
        $actual: _($test-falsey, slice, compact, slice);

        @include assert-equal(length($actual), 0);

        $actual: _($test-falsey, slice, push true 1, compact, push 'a', slice);
        $expected: (true, 1, 'a');

        @include assert-true(test-lists-equal($actual, $expected));
    }
}

@include test-module('flow methods') {
    @each $method-name in ('flow', 'flow-right') {
        $func: unquote('_#{$method-name}');
        $is-flow: ($method-name == 'flow');

        @include test('#{$func} should supply each function with the return value of the previous') {
            $combined: if($is-flow, call($func, test-add, test-square, test-fixed), call($func, test-fixed, test-square, test-add));

            $actual: _call($combined, null, 1, 2);
            $expected: 9.0;

            @include assert-equal($actual, $expected);
        }

        @include test('#{$func} should return a new function') {
            @include assert-unequal(_call($func, null, _noop), _noop);
        }

        @include test('#{$func} should return a noop function when no arguments are provided') {
            $combined: call($func);

            @include assert-equal(_call($combined), _call(_noop));
        }

        @include xit('#{$func} should return a wrapped value when chaining') {}
    }
}

@include test-module('_constant') {
    @include test('should create a function that returns value') {
        $constant: _constant(('a': 1));
        $actual: _call($constant);
        $expected: ('a': 1);

        @include assert-equal($actual, $expected);
    }

    @include test('should work with falsey values') {
        @each $value in $test-falsey {        
            $constant: _constant($value);
            $actual: _call($constant);
            $expected: $value;

            @include assert-equal($actual, $expected);
        }

        $constant: _constant();
        $actual: _call($constant);
        $expected: null;

        @include assert-equal($actual, $expected);    
    }

    @include xit('should return a wrapped value when chaining') {}
}

@function test-count-by-1($value, $args...) {
    @return floor($value);
}
@function test-count-by-2($value, $args...) {
    @return $value > 2;
}
@include test-module('_count-by') {
    $list: (4.2, 6.1, 6.4);

    // @include test('should work with an iteratee') {
    //     $actual: _count-by($list, test-count-by-1);
    //     $expected: (4: 1, 6: 2);

    //     @include assert-equal($actual, $expected);
    // }

    // @include test('should use _identity when iteratee is null') {
    //     $list: (4, 6, 6);
    //     $actual: _count-by($list, null);
    //     $expected: (4: 1, 6: 2);

    //     @include assert-equal($actual, $expected);

    //     $actual: _count-by($list);

    //     @include assert-equal($actual, $expected);
    // }

    // @include xit('should provide the correct iteratee arguments') {}

    // @include xit('should support the this-arg argument') {}

    // @include xit('should only add values to own, not inherited, properties') {}

    // @include test('should work with a _pluck style iteratee') {
    //     $map: (
    //         (a: 'one', len: 3),
    //         (a: 'two', len: 3),
    //         (a: 'three', len: 5),
    //     );
    //     $actual: _count-by($map, 'len');
    //     $expected: (3: 2, 5: 1);

    //     @include assert-equal($actual, $expected);
    // }

    @include test('should work with a number for iteratee') {
        $list: (1 'a', 2 'a', 2 'b');
        $actual: _count-by($list, 1);
        $expected: (1: 1, 2: 2);

        @include assert-equal($actual, $expected);
    }

    @include test('should work with an object for collection') {
        $actual: _count-by(('a': 4.2, 'b': 6.1, 'c': 6.4), test-count-by-1);
        $expected: (4: 1, 6: 2);

        @include assert-equal($actual, $expected);
    }

    @include test('should work in a lazy chain sequence') {
        $list: (1 2 1 3);
        $foo: _($list, count-by _identity, map test-double);
        $actual: _($list, count-by _identity, map test-double, filter test-count-by-2, take);
        $expected: (4,);

        @include assert-true(test-lists-equal($actual, $expected));
    }
}

@function test-call-1() {
    @return 'foo';
}
@function test-call-2() {
    @return __this('value');
}
@function test-call-3($value) {
    @return __this('value') + $value;
}
@include test-module('_call') {
    @include test('should be callable with only a function with no args') {
        $actual: _call(test-call-1);
        $expected: 'foo';

        @include assert-equal($actual, $expected);
    }

    @include test('should call a function with no args and with a thisArg') {
        $_: __scope(('value': 'foobar'));
        $actual: _call(test-call-2, $__current-scope__);
        $_: __scope(false);

        $expected: 'foobar';

        @include assert-equal($actual, $expected);
    }

    @include test('should call a function with args and without a thisArg') {
        $actual: _call(test-add, null, 1, 2);
        $expected: 3;

        @include assert-equal($actual, $expected);
    }

    @include test('should call a function with args and with a thisArg') {
        $value: 'second';

        $_: __scope(('value': 'first'));
        $actual: _call(test-call-3, $__current-scope__, $value);
        $_: __scope(false);

        $expected: 'firstsecond';

        @include assert-equal($actual, $expected);
    }
}

@function test-callback-1($args...) {
    @return join((), $args);
}
@function test-callback-2($args...) {
    $result: __this('a');
    $result: join(($result), $args);

    @return $result;
}
@function test-callback-3($callback, $args...) {
    @return _call($callback);
}
@function test-callback-4() {
    @return false;
}
@include test-module('_callback') {
    @include test('should provide arguments to func') {
        $callback: _callback(test-callback-1);

        $actual: _call($callback, null, 'a', 'b', 'c', 'd', 'e', 'f');
        $expected: ('a', 'b', 'c', 'd', 'e', 'f');

        @include assert-equal($actual, $expected);
    }

    @include test('should return _identity when func is nullish') {
        $actual: _call(_callback());
        $expected: null;

        @include assert-equal($actual, $expected);

        $actual: _call(_callback(null));
        $expected: null;

        @include assert-equal($actual, $expected);
    }

    @include xit('should not error when func is nullish and a thisArg is provided') {
        // todo
    }

    @include xit('should create a callback with a falsey thisArg') {
        // todo
    }

    @include test('should return a callback created by _matches when func is an object') {
        $callback: _callback(('a': 1));
        $actual: _call($callback, null, ('a': 1, 'b': 2));
        $expected: true;

        @include assert-equal($actual, $expected);
    }

    @include test('should return a callback created by _property when func is a number or string') {
        $list: ('a');
        $callback: _callback(1);
        $actual: _call($callback, null, $list);
        $expected: 'a';

        @include assert-equal($actual, $expected);

        $callback: _callback('first');
        $actual: _call($callback, null, ('first': 'a'));
        $expected: 'a';

        @include assert-equal($actual, $expected);
    }

    @include xit('should work with functions created by _partial and _partial-right') {
        $_: __scope(('a': 1));
        $callback: _callback(test-callback-2, _partial(test-callback-2, 2), $__current-scope__);
        $_: __scope(false);

        $actual: _call($callback, null, 3);
        $expected: (1 2 3);

        @include assert-equal($actual, $expected);
    }

    @include test('should return the function provided when there is no this reference') {
        $actual: _callback(test-add);
        $expected: test-add;

        @include assert-equal($actual, $expected);
    }

    @include test('should work as an iteratee for _map') {
        $fn: test-callback-4;
        $list: ($fn $fn $fn);
        $expected: _map($list, _constant(false));
        $callbacks: _map($list, _callback);

        $actual: _map($callbacks, test-callback-3);

        @include assert-equal($actual, $expected);
    }

    @include test('should work as a shifted argument callback with a list for function') {
        $shifted-args: _callback(lighten 100%);
        $actual: _exec($shifted-args, black);

        @include assert-equal($actual, white);
    }
}

@include test-module('_defaults') {
    @include test('should assign properties of a source object if missing on the destination object') {
        $value: ('a': 1);
        $defaults: ('a': 2, 'b': 2);
        $actual: _defaults($value, $defaults);
        $expected: ('a': 1, 'b': 2);

        @include assert-equal($actual, $expected);
    }

    @include test('should accept multiple source objects') {
        $expected: ('a': 1, 'b': 2, 'c': 3);
        $actual: _defaults(('a': 1, 'b': 2), ('b': 3), ('c': 3));

        @include assert-equal($actual, $expected);

        $actual: _defaults(('a': 1, 'b': 2), ('b': 3, 'c': 3), ('c': 2));

        @include assert-equal($actual, $expected);
    }

    @include test('should not overwrite null values') {
        $actual: _defaults(('a': null), ('a': 1));

        @include assert-equal(__get($actual, 'a'), null);
    }

    @include test('should overwrite undefined values') {
        $actual: _defaults(('a': $__undefined__), ('a': 1));

        @include assert-equal(__get($actual, 'a'), 1);
    }
}

@function test-difference-1($args...) {
    @return $args;
}
@include test-module('_difference') {
    @include test('should return the difference of the given arrays') {
        $actual: _difference(1 2 3 4 5, 5 2 10);

        @include assert-equal($actual, 1 3 4);

        $actual: _difference(1 2 3 4 5, 5 2 10, 8 4);

        @include assert-equal($actual, 1 3);
    }

    @include test('should ignore values that are not arrays or arguments objects') {
        $list: (0 1 null 3);
        $args: test-difference-1(1, 2, 3);

        @include assert-equal(
            _difference($list, 3, null, ('0': 1)),
            $list);
        @include assert-equal(
            _difference(null, $list, null, 2 1),
            0 null 3);
        @include assert-equal(
            _difference(null, $list, null, $args),
            0 null);
    }
}

@function test-drop-1($value, $args...) {
    @return $value > 2;
}
@include test-module('_drop') {
    $list: 1 2 3;

    @include test('should drop the first two elements') {
        $actual: _drop($list, 2);
        $expected: (3,);

        @include assert-true(test-lists-equal($actual, $expected));
    }

    @include test('should treat falsey n values, except nullish, as \0') {
        @each $value in $test-falsey {        
            $actual: _drop($list, $value);
            $expected: if($value == null, (2, 3), $list);

            @include assert-true(test-lists-equal($actual, $expected));
        }
    }

    @include test('should return all elements when n is less than one') {
        @each $value in 0, -1, -9999 {
            $actual: _drop($list, $value);
            $expected: $list;

            @include assert-equal($actual, $expected);
        }
    }

    @include test('should return an empty list when n is greater than or equal to length of list') {
        @each $value in 3, 4, pow(2, 32), 9999 {
            $actual: _drop($list, $value);
            $expected: ();

            @include assert-equal($actual, $expected);
        }
    }

    @include test('should work as an iteratee for _map') {
        $list: (1 2 3, 4 5 6, 7 8 9);
        $actual: _map($list, _drop);
        $expected: (2 3, 5 6, 8 9);

        @include assert-true(test-lists-equal($actual, $expected));
    }

    @include test('should work in a lazy chain sequence') {
        $list: 1 2 3 4 5 6 7 8 9 10;
        $predicate: test-drop-1;

        $actual: _($list, drop 2, drop);
        $expected: 4 5 6 7 8 9 10;

        @include assert-equal($actual, $expected);

        $actual: _($list, filter $predicate, drop 2, drop);
        $expected: 6 7 8 9 10;

        @include assert-equal($actual, $expected);

        $actual: _($list, drop 2, drop-right, drop, drop-right 2);
        $expected: 4 5 6 7;

        @include assert-equal($actual, $expected);

        $actual: _($list, drop, filter $predicate, drop 2, drop-right, drop, drop-right 2);
        $expected: 6 7;

        @include assert-equal($actual, $expected);
    }
}

@function test-drop-right-1($value, $args...) {
    @return $value < 9;
}
@include test-module('_drop-right') {
    $list: 1 2 3;

    @include test('should drop the first two elements') {
        $actual: _drop-right($list, 2);
        $expected: (1,);

        @include assert-true(test-lists-equal($actual, $expected));
    }

    @include test('should treat falsey n values, except nullish, as zero') {
        @each $value in $test-falsey {        
            $actual: _drop-right($list, $value);
            $expected: if($value == null, (1, 2), $list);

            @include assert-true(test-lists-equal($actual, $expected));
        }
    }

    @include test('should return all elements when n is less than one') {
        @each $value in 0, -1, -9999 {
            $actual: _drop-right($list, $value);
            $expected: $list;

            @include assert-equal($actual, $expected);
        }
    }

    @include test('should return an empty list when n is greater than or equal to length of list') {
        @each $value in 3, 4, pow(2, 32), 9999 {
            $actual: _drop-right($list, $value);
            $expected: ();

            @include assert-equal($actual, $expected);
        }
    }

    @include test('should work as an iteratee for _map') {
        $list: (1 2 3, 4 5 6, 7 8 9);
        $actual: _map($list, _drop-right);
        $expected: (1 2, 4 5, 7 8);

        @include assert-true(test-lists-equal($actual, $expected));
    }

    @include test('should work in a lazy chain sequence') {
        $list: 1 2 3 4 5 6 7 8 9 10;
        $predicate: test-drop-right-1;

        $actual: _($list, drop-right 2, drop-right);
        $expected: 1 2 3 4 5 6 7;

        @include assert-equal($actual, $expected);

        $actual: _($list, filter $predicate, drop-right 2, drop-right);
        $expected: 1 2 3 4 5;

        @include assert-equal($actual, $expected);

        $actual: _($list, drop-right 2, drop, drop-right, drop 2);
        $expected: 4 5 6 7;

        @include assert-equal($actual, $expected);

        $actual: _($list, drop-right, filter $predicate, drop-right 2, drop, drop-right, drop 2);
        $expected: 4 5;

        @include assert-equal($actual, $expected);
    }
}


@function test-drop-right-while-1($value, $args...) {
    @return $value > 1;
}
@function test-drop-right-while-2($num, $index, $args...) {
    @return nth(__this('list'), $index) > 1;
}
@include test-module('_drop-right-while') {
    $list: 1 2 3;
    $maps: (
        (a: 0, b: 0),
        (a: 1, b: 1),
        (a: 2, b: 2)
    );

    @include test('should drop elements while predicate returns truthy') {
        $actual: _drop-right-while($list, test-drop-right-while-1);
        $expected: (1,);

        @include assert-true(test-lists-equal($actual, $expected));
    }

    // @include test('should support the this-arg argument') {} // todo

    @include test('should work with a _pluck style predicate') {
        $actual: _drop-right-while($maps, 'b');
        $expected: _slice($maps, 0, 1);

        @include assert-equal($actual, $expected);
    }

    @include test('should work with a _where style predicate') {
        $actual: _drop-right-while($maps, ('b': 2));
        $expected: _slice($maps, 0, 2);

        @include assert-equal($actual, $expected);
    }

    @include xit('should return a wrapped value when chaining');
}

@function test-drop-while-1($num, $args...) {
    @return $num < 3;
}
@include test-module('_drop-while') {
    $list: 1 2 3;
    $maps: (
        (a: 2, b: 2),
        (a: 1, b: 1),
        (a: 0, b: 0)
    );

    @include test('should drop elements while predicate returns truthy') {
        $actual: _drop-while($list, test-drop-while-1);
        $expected: (3,);

        @include assert-true(test-lists-equal($actual, $expected));
    }

    // @include test('should support the this-arg argument') {} // todo

    @include test('should work with a _pluck style predicate') {
        $actual: _drop-while($maps, 'b');
        $expected: _slice($maps, 2);

        @include assert-equal($actual, $expected);
    }

    @include test('should work with a _where style predicate') {
        $actual: _drop-while($maps, ('b': 2));
        $expected: _slice($maps, 1);

        @include assert-equal($actual, $expected);
    }

    @include xit('should return a wrapped value when chaining');
}

@include test-module('_either') {
    @include test('should return the first value if it is truthy') {
        @include assert-equal(_either('abc', true), 'abc');
        @include assert-equal(_either('abc', 'def'), 'abc');
        @include assert-equal(_either((false: false), true), (false: false));
    }

    @include test('should return the second value if the first one is truthy, regardless of if the second value is truthy') {
        @each $value in $test-falsey {
            @include assert-equal(_either($value, 'abc'), 'abc');
            @include assert-equal(_either($value, false), false);
            @include assert-equal(_either($value, null), null);
        }
    }

    @include test('should work when only given one argument') {
        @include assert-equal(_either('abc'), 'abc');
    }

    @include test('should return null if only argument is falsey') {
        @each $value in $test-falsey {
            @include assert-equal(_either($value), null);
        }
    }

    @include test('should work with a predicate arg') {
        @include assert-equal(_either('', 'abc', _identity), '');
        @include assert-equal(_either(false, true, __is-falsey), false);
        @include assert-equal(_either(null, true, __is-falsey), null);
        @include assert-equal(_either('abc', 'def', _partial-right(_starts-with, 'q')), 'def');
    }

    @include test('should work with shifted argument syntax for predicate') {
        $list-1: 1 2 3;
        $list-2: 4 5 6;

        @include assert-equal(_either($list-1, $list-2, index 2), $list-1);
        @include assert-equal(_either($list-1, $list-2, index 5), $list-2);
        @include assert-equal(_either($list-1, $list-2, index 7), $list-2);
    }
}

@include test-module('_ends-with') {
    $string: 'abc';

    @include test('should return true if a string ends with target') {
        $actual: _ends-with($string, 'c');
        $expected: true;

        @include assert-equal($actual, $expected);
    }

    @include test('should return false if a string does not end with target') {
        $actual: _ends-with($string, 'b');
        $expected: false;

        @include assert-equal($actual, $expected);
    }

    @include test('should work with a position argument') {
        $actual: _ends-with($string, 'b', 2);
        $expected: true;

        @include assert-equal($actual, $expected);
    }

    @include test('should work with position greater than or equal to string length') {
        @each $position in 3, 5, 9999 {        
            $actual: _ends-with($string, 'c', $position);
            $expected: true;

            @include assert-equal($actual, $expected);
        }
    }

    @include test('should treat falsey position values, except undefined, as zero') {
        @each $position in $test-falsey {        
            $actual: _ends-with($string, if(__is-undefined($position), 'c', ''), $position);
            $expected: true;

            @include assert-equal($actual, $expected);
        }
    }

    @include test('should treate a negative position as zero') {
        @each $position in -1, -3, -9999 {
            @each $char in ('a', 'b', 'c') {            
                $actual: _ends-with($string, $char, $position);
                $expected: false;

                @include assert-equal($actual, $expected);
            }
        }
    }

    @include test('should return true when target is an empty string regardless of position') {
        @each $position in -9999, -3, -1, 0, 1, 2, 3, 5, 9999 {        
            $actual: _ends-with($string, '', $position);
            $expected: true;

            @include assert-equal($actual, $expected);
        }
    }
}

@include test-module('_ends-with-any') {
    @include test('should work with a list for target') {
      @include assert-equal(_ends-with-any('abc', 'c' 'd' 'e'), true);
      @include assert-equal(_ends-with-any('abc', 'bcc' 'zbc' 'cd'), false);
    }
}

@include test-module('_escape') {
    $escaped: '&amp;&lt;&gt;&quot;&#39;&#96;\/';
    $unescaped: '&<>"' + "'`/";

    $escaped: $escaped + $escaped;
    $unescaped: $unescaped + $unescaped;

    @include test('should escape values') {
        $actual: _escape($unescaped);
        $expected: $escaped;

        @include assert-equal($actual, $expected);
    }

    @include test('should not escape the forward slash character') {
        $actual: _escape('/');
        $expected: '/';

        @include assert-equal($actual, $expected);
    }

    @include test('should handle strings with nothing to escape') {
        $actual: _escape('abc');
        $expected: 'abc';

        @include assert-equal($actual, $expected);
    }

    @include test('should escape the same characters unescaped by _unescape') {
        $actual: _escape(_unescape($escaped));
        $expected: $escaped;

        @include assert-equal($actual, $expected);
    }
}

@include test-module('_every') {
    @include test('should return true for empty collections') {
        $actual: _every((), _identity);
        $expected: true;

        @include assert-equal($actual, $expected);
    }

    @include test('should return true if predicate returns truthy for all elements in the collection') {
        $actual: _every(true 1 'a', _identity);
        $expected: true;

        @include assert-equal($actual, $expected);
    }

    @include test('should return false as soon as predicate returns falsey') {
        $actual: _every(true null true, _identity);
        $expected: false;

        @include assert-equal($actual, $expected);
    }

    @include test('should work with a _pluck style predicate') {
        $maps: (('a': 0, 'b': 1), ('a': 1, 'b': 2));
        $actual: _every($maps, 'a');
        $expected: false;

        @include assert-equal($actual, $expected);

        $actual: _every($maps, 'b');
        $expected: true;

        @include assert-equal($actual, $expected);
    }

    @include test('should work with a _where style predicate') {
        $maps: (('a': 0, 'b': 0), ('a': 0, 'b': 1));
        $actual: _every($maps, ('a': 0));
        $expected: true;

        @include assert-equal($actual, $expected);

        $actual: _every($maps, ('b': 1));
        $expected: false;

        @include assert-equal($actual, $expected);
    }

    @include test('should use _identity when predicate is nullish') {
        $list: (0,);

        $actual: _every($list, null);
        $expected: false;

        @include assert-equal($actual, $expected);

        $actual: _every($list);
        $expected: false;

        @include assert-equal($actual, $expected);
    }

    @include test('should be aliased') {
        $list: 1 2 3;
        $actual: _every($list);
        $expected: _all($list);

        @include assert-equal($actual, $expected);
    }
}

@function test-filter-1($num, $args...) {
    @return $num % 2;
}
@include test-module('_filter') {
    @include test('should return elements predicate returns truthy for') {
        $actual: _filter(1 2 3, test-filter-1);
        $expected: 1 3;

        @include assert-equal($actual, $expected);
    }

    @include test('should be aliased') {
        $actual: _select(1 2 3, test-filter-1);
        $expected: _filter(1 2 3, test-filter-1);

        @include assert-equal($actual, $expected);
    }

    @include test('should work with shifted argument syntax for function') {
        $actual: _filter(black white yellow purple, lightness);

        @include assert-equal($actual, white yellow purple);
    }
}

@function test-find-1($map, $args...) {
    @return __is-truthy(__get($map, 'a'));
}
@function test-find-2($map, $args...) {
    @return __get($map, 'a') == 3;
}
@function test-find-3($value, $args...) {
    @return if(type-of($value) == 'number', $value < 3, false);
}
@function test-find-4($chr, $index, $args...) {
    @return $index <= 2;
}
@each $method-name in 'find', 'find-last', 'find-index', 'find-last-index', 'find-key', 'find-last-key' {
    @include test-module('_#{$method-name}') {
        $func: unquote('_#{$method-name}');

        $maps: (
            ('a': 0, 'b': 0),
            ('a': 1, 'b': 1),
            ('a': 2, 'b': 2),
        );

        $expected-values: __get((
            'find': nth($maps, 2) $__undefined__ nth($maps, 3) nth($maps, 2),
            'find-last': nth($maps, 3) $__undefined__ nth($maps, 3) nth($maps, 3),
            'find-index': 2 -1 3 2,
            'find-last-index': 3 -1 3 3,
            'find-key': 2 null 3 2,
            'find-last-key': 3 null 3 3
        ), $method-name);

        @include test('should return the correct value') {
            $actual: _call($func, null, $maps, test-find-1);
            $expected: nth($expected-values, 1);

            @include assert-equal($actual, $expected);
        }

        @include xit('should work with a this-arg') {} // todo

        @include test('should return expected value if value is not found') {
            $actual: _call($func, null, $maps, test-find-2);
            $expected: nth($expected-values, 2);

            @include assert-equal($actual, $expected);
        }

        @include test('should work with a _pluck style predicate') {
            $actual: _call($func, null, $maps, 'b');
            $expected: nth($expected-values, 4);

            @include assert-equal($actual, $expected); 
        }

        @include test('should work with a _where style predicate') {
            $actual: _call($func, null, $maps, ('b': 2));
            $expected: nth($expected-values, 3);

            @include assert-equal($actual, $expected); 
        }

        @include test('should return expected value for empty collections') {
            $actual: _call($func, null, (), ('a': 3));
            $expected: nth($expected-values, 2);

            @include assert-equal($actual, $expected); 
        }

        @include test('should work with an object for collection') {
            $actual: _call($func, null, ('a': 1, 'b': 2, 'c': 3), test-find-3);
            $expected: __get((
                'find': 1,
                'find-last': 2,
                'find-key': 'a',
                'find-last-key': 'b'
            ), $method-name);

            @if ($expected != null) {
                @include assert-equal($actual, $expected); 
            } @else {
                @include assert-equal(true, true);
            }
        }

        @include test('should work with a string for collection') {
            $actual: _call($func, null, 'abc', test-find-4);
            $expected: __get((
                'find': 'a',
                'find-last': 'b',
                'find-index': 1,
                'find-last-index': 1
            ), $method-name);

            @if ($expected != null) {
                @include assert-equal($actual, $expected); 
            } @else {
                @include assert-equal(true, true);
            }
        }

        @if ($method-name == 'find') {
            @include test('should be aliased') {
                $actual: _detect(1 2 3, test-is-even);
                $expected: _find(1 2 3, test-is-even);

                @include assert-equal($actual, $expected); 
            }
        }
    }
}

@include test-module('_find-where') {
    $maps: (
        ('a': 1),
        ('a': 1),
        ('a': 1, 'b': 2),
        ('a': 2, 'b': 2),
        ('a': 3),
    );

    @include test('should filter by source properties') {
        @include assert-equal(
            _find-where($maps, ('a': 1)),
            nth($maps, 1));
        @include assert-equal(
            _find-where($maps, ('a': 2)),
            nth($maps, 4));
        @include assert-equal(
            _find-where($maps, ('a': 3)),
            nth($maps, 5));
        @include assert-equal(
            _find-where($maps, ('b': 1)),
            $__undefined__);
        @include assert-equal(
            _find-where($maps, ('b': 2)),
            nth($maps, 3));
        @include assert-equal(
            _find-where($maps, ('a': 1, 'b': 2)),
            nth($maps, 3));
    }

    @include test('should match all elements when provided an empty source') {
        $actual: _find-where($maps, ());
        $expected: nth($maps, 1);

        @include assert-equal($actual, $expected);
    }
}

@include test-module('_first') {
    $list: 1 2 3;

    @include test('should return the first element') {
        $actual: _first($list);
        $expected: 1;

        @include assert-equal($actual, $expected);
    }

    @include test('should return null when querying empty arrays') {
        $actual: _first(());
        $expected: null;

        @include assert-equal($actual, $expected);
    }

    @include test('should work as an iteratee for _map') {
        $list: (1 2 3, 4 5 6, 7 8 9);
        $actual: _map($list, _first);
        $expected: 1 4 7;

        @include assert-equal($actual, $expected);
    }

    @include test('should work in a lazy chain sequence') {
        $list: 1 2 3 4;
        $actual: _($list, filter test-is-even, first);
        $expected: 2;

        @include assert-equal($actual, $expected);
    }

    @include test('should be aliased') {
        $actual: _head($list);
        $expected: _first($list);

        @include assert-equal($actual, $expected);
    }
}

@function test-take-1($value, $args...) {
    @return $value > 2;
}
@include test-module('_take') {
    $list: 1 2 3;

    @include test('should take the first two elements') {
        $actual: _take($list, 2);
        $expected: 1 2;

        @include assert-equal($actual, $expected);
    }

    @include test('should treat falsey n values, except nullish, as zero') {
        @each $value in $test-falsey {        
            $actual: _take($list, $value);
            $expected: if($value == null, (1,), ());

            @if $value == null {
                @include assert-true(test-lists-equal($actual, $expected));
            } @else {
                @include assert-equal($actual, $expected);
            }
        }
    }

    @include test('should return an empty list when n is less than one') {
        @each $value in 0, -1, -9999 {        
            $actual: _take($list, $value);
            $expected: ();

            @include assert-equal($actual, $expected);
        }
    }

    @include test('should return all elements when n is greater than list length') {
        @each $value in 3, 4, pow(2, 32), 9999 {        
            $actual: _take($list, $value);
            $expected: $list;

            @include assert-equal($actual, $expected);
        }
    }

    @include test('should work as an iteratee for _map') {
        $list: (1 2 3, 4 5 6, 7 8 9);
        $actual: _map($list, _take);
        $expected: ((1,), (4,), (7,));

        @include assert-true(test-lists-equal($actual, $expected));
    }

    @include test('should work in a lazy chain sequence') {
        $list: 1 2 3 4 5 6 7 8 9 10;

        $actual: _($list, take 2, take);
        $expected: (1,);

        @include assert-true(test-lists-equal($actual, $expected));

        $actual: _($list, filter test-take-1, take 2, take);
        $expected: (3,);

        @include assert-true(test-lists-equal($actual, $expected));

        $actual: _($list, take 6, take-right 4, take 2, take-right);
        $expected: (4,);

        @include assert-true(test-lists-equal($actual, $expected));

        $actual: _($list, take (length($list) - 1), filter test-take-1, take 6, take-right 4, take 2, take-right);
        $expected: (6,);

        @include assert-true(test-lists-equal($actual, $expected));
    }
}

@function test-take-right-1($value, $args...) {
  @return $value < 9;
}
@include test-module('Sassdash') {
  @include test('_take-right') {
    $list: 1 2 3;

    $actual: _take-right($list, 2);
    $expected: 2 3;

    @include assert-true(test-lists-equal($actual, $expected),
      'should take the last two elements');

    @each $value in $test-falsey {
      $actual: _take-right($list, $value);
      $expected: if($value == null, (3,), $test-empty-list);

      @include assert-true(test-lists-equal($actual, $expected),
        'should treat falsey n value, except nullish, as 0');
    }

    @each $value in 0, -1, -9999 {
      @include assert-true(test-lists-equal(_take-right($list, $value), $test-empty-list),
        'should return an empty list when n < 1');
    }

    @each $value in 3, 4, pow(2, 32), 9999 {
      @include assert-true(test-lists-equal(_take-right($list, $value), $list),
        'should return all elements when n >= list length');
    }

    @include test-group() {
      $list: 1 2 3, 4 5 6, 7 8 9;
      $actual: _map($list, _take-right);
      $expected: (3,), (6,), (9,);

      @include assert-true(test-lists-equal($actual, $expected),
        'should work as iteratee for map');
    }

    @include test-group() {
      $list: 1 2 3 4 5 6 7 8 9 10;
      $predicate: test-take-right-1;
      $actual: _($list, take-right 2, take-right);

      @include assert-true(test-lists-equal($actual, (10,)),
        'should work in a lazy chain sequence');

      $actual: _($list, filter $predicate, take-right 2, take-right);

      @include assert-true(test-lists-equal($actual, (8,)),
        'should work in a lazy chain sequence');

      $actual: _($list, take-right 6, take 4, take-right 2, take);

      @include assert-true(test-lists-equal($actual, (7,)),
        'should work in a lazy chain sequence');

      $actual: _($list, filter $predicate, take-right 6, take 4, take-right 2, take);

      @include assert-true(test-lists-equal($actual, (5,)),
        'should work in a lazy chain sequence');
    }
  }
}

@function test-take-right-while-1($num, $args...) {
  @return $num > 1;
}
@include test-module('Sassdash') {
  @include test('_take-right-while') {  
    $list: 1 2 3;
    $maps: (
      ('a': 0, 'b': 0),
      ('a': 1, 'b': 1),
      ('a': 2, 'b': 2),
    );

    $actual: _take-right-while($list, test-take-right-while-1);

    @include assert-equal($actual, 2 3,
      'should take elements while predicate returns truthy');

    @include assert-true(true, 'should support the this-arg argument'); // todo

    @include assert-equal(_take-right-while($maps, 'b'), _slice($maps, 1),
      'should work with a _pluck style predicate');

    @include assert-equal(_take-right-while($maps, ('b': 2)), _slice($maps, 2),
      'should work with a _where style predicate');

    @include assert-equal(_($list, take-right-while test-take-right-while-1), 2 3,
      'should return expected value when chaining');
  }
}

@function test-take-while-1($num, $args...) {
  @return $num < 3;
}
@include test-module('Sassdash') {
  @include test('_take-while') {  
    $list: 1 2 3;
    $maps: (
      ('a': 2, 'b': 2),
      ('a': 1, 'b': 1),
      ('a': 0, 'b': 0),
    );

    $actual: _take-while($list, test-take-while-1);

    @include assert-equal($actual, 1 2,
      'should take elements while predicate returns truthy');

    @include assert-true(true, 'should provide the correct predicate arguments'); // not implemented

    @include assert-true(true, 'should support the this-arg argument'); // todo

    @include assert-equal(_take-while($maps, 'b'), _slice($maps, 0, 2),
      'should work with a _pluck style predicate');

    @include assert-equal(_take-while($maps, ('b': 2)), _slice($maps, 0, 1),
      'should work with a _where style predicate');

    @include assert-equal(_($list, take-while test-take-while-1), 1 2,
      'should return expected value when chaining');
  }
}

@function test-flatten-1($args...) {
  @return $args;
}
@include test-module('Sassdash') {
  $args: test-flatten-1(1, 2, 3);

  @include test('flatten methods') {
    $list: ((('a',),), (('b',),));

    @include assert-true(test-lists-equal(_flatten($list), (('a',), ('b',))),
      'should perform a shallow flatten');

    $expected: ('a', 'b');

    @include assert-true(test-lists-equal(_flatten($list, true), $expected),
      'should work with isDeep');

    @include assert-true(test-lists-equal(_flatten-deep($list), $expected),
      'should work with isDeep');

    $list: ($args, ($args,));
    $expected: (1, 2, 3, $args);

    @include assert-true(test-lists-equal(_flatten($list), $expected),
      'should flatten arglists');

    $expected: (1, 2, 3, 1, 2, 3);

    @include assert-true(test-lists-equal(_flatten($list, true), $expected),
      'should flatten arglists');

    @include assert-true(test-lists-equal(_flatten-deep($list), $expected),
      'should flatten arglists');

    $list: (((('a',),),), ((('b',),),));

    @include assert-true(test-lists-equal(_map($list, _flatten), ((('a',),), (('b',),))),
      'should work as an iteratee for _map');

    @include assert-true(test-lists-equal(_map($list, _flatten-deep), (('a',), ('b',))),
      'should work as an iteratee for _map');
    
    $list: ((), ((),), ((), (((),),),));
    $expected: ((), (), (((),),));

    @include assert-true(test-lists-equal(_flatten($list), $expected),
      'should work with empty lists');

    @include assert-true(test-lists-equal(_flatten($list, true), $test-empty-list),
      'should work with empty lists');

    @include assert-true(test-lists-equal(_flatten-deep($list), $test-empty-list),
      'should work with empty lists');

    $list: (1, (2,), (3, (4,)));
    $expected: (1, 2, 3, (4,));

    @include assert-true(test-lists-equal(_flatten($list), $expected),
      'should support flattening of nested lists');

    $expected: (1, 2, 3, 4);

    @include assert-true(test-lists-equal(_flatten($list, true), $expected),
      'should support flattening of nested lists');

    @include assert-true(test-lists-equal(_flatten-deep($list), $expected),
      'should support flattening of nested lists');

    $expected: ();

    @include assert-true(test-lists-equal(_flatten(('a': 1)), $expected),
      'should return empty list for non list-like objects');

    @include assert-true(test-lists-equal(_flatten(('a': 1), true), $expected),
      'should return empty list for non list-like objects');

    @include assert-true(test-lists-equal(_flatten-deep(('a': 1)), $expected),
      'should return empty list for non list-like objects');
  }
}

@include test-module('Sassdash') {
  @include test('_for-each') {
    @include assert-equal(_each(1 2 3, test-square), _for-each(1 2 3, test-square),
      'should be aliased');
  }

  @include test('_for-each-right') {
    @include assert-equal(_each-right(1 2 3, test-square), _for-each-right(1 2 3, test-square),
      'should be aliased');
  }
}

@include test-module('Sassdash') {
  @include test('map assignments') {  
    // TODO: add 'merge'
    @each $method-name in 'assign', 'defaults' {
      $func: unquote('_#{$method-name}');

      @each $value in $test-falsey {
        $actual: _call($func, null, $value);
        $expected: $value;

        @include assert-equal($actual, $expected,
          '#{$func} should pass thru falsey map values');
      }

      $list: (('b': 2), ('c': 3));
      $actual: _reduce($list, $func, ('a': 1));
      $expected: ('a': 1, 'b': 2, 'c': 3);

      @include assert-equal($actual, $expected,
        '#{$func} should work as an iteratee for _reduce');
    }
  }
}

@function test-group-by-1($num, $args...) {
  @return floor($num);
}
@include test-module('_group-by') {
  $list: 4.2 6.1 6.4;

  @include test('should use _identity when iteratee is nullish') {
    $list: 4 6 6;
    $expected: (4: (4,), 6: (6, 6));

    @include assert-equal(_group-by($list), $expected);
    @include assert-equal(_group-by($list, null), $expected);

  }

  @include test('should work with a _pluck style iteratee') {
    $map: ('number': 'one', 'len': 3) ('number': 'two', 'len': 3) ('number': 'three', 'len': 5);
    $expected: (3: (("number": "one", "len": 3), ("number": "two", "len": 3)), 5: ((("number": "three", "len": 5),)));

    @include assert-equal(_group-by($map, 'len'), $expected);
  }

  @include test('should work with a number for iteratee') {
    $list: (1 'a', 2 'a', 2 'b');

    @include assert-equal(_group-by($list, 1), (1: (1 'a',), 2: (2 'a', 2 'b')));
    @include assert-equal(_group-by($list, 2), ('a': (1 'a', 2 'a'), 'b': (2 'b',)));
  }

  @include test('should work with a map for collection') {
    $actual: _group-by(('a': 4.2, 'b': 6.1, 'c': 6.4), test-group-by-1);
    $expected: (4: (4.2,), 6: (6.1, 6.4));

    @include assert-equal($actual, $expected);
  }
}

@function TestHas($a) {
  @return ('a': $a);
}
@include test-module('_has') {
  @include test('should check for own properties') {
    $map: ('a': 1);

    @include assert-equal(_has($map, 'a'), true);
    @include assert-equal(_has($map, 'b'), false);
  }

  @include test('should not check for inherited properties') {
    $map: __new(TestHas, ('a': 1));

    @include assert-equal(_has($map, '_type'), false);
    @include assert-equal(_has($map, 'a'), true);
  }

  @include test('should return false for non-maps') {
    @each $value in join($test-falsey, true 1 'a') {
      @include assert-equal(_has($value, 'a'), false);
    }
  }
}

@include test-module('_identity') {
  @include test('should return the first argument provided') {
    $map: ('name': 'fred');

    @include assert-equal(_identity($map), $map);
  }
}

@include test-module('_includes') {
  $map: ('a': 1, 'b': 2, 'c': 3, 'd': 4);

  @each $item in ('an arglist': test-args(1, 2, 3)), ('a list': 1 2 3 4), ('a map': $map), ('a string': '1234') {
    @each $key, $collection in $item {    
      $values: __to-list($collection);

      @include test('should work with #{$key} and return true for matched values') {
        @include assert-equal(_includes($collection, if($key == 'a string', '3', 3)), true);
      }

      @include test('should work with #{$key} and return false for unmatched values') {
        @include assert-equal(_includes($collection, 5), false);
      }

      @include test('should work with #{$key} and a positive from-index') {
        @include assert-equal(_includes($collection, nth($values, 2), 2), true);
        @include assert-equal(_includes($collection, nth($values, 1), 2), false);
      }

      @include test('should work with #{$key} and a from-index >= collection length') {
        @include assert-equal(_includes($collection, nth($values, 1), 5), false);
      }

      @include test('should work with #{$key} and treat falsey and non-number from-index values as 1') {
        @each $value in join($test-falsey, '1') {
          @include assert-equal(_includes($collection, nth($values, 1), $test-falsey), true);
        }
      }

      @include test('should work with #{$key} and negative from-index') {
        @include assert-equal(_includes($collection, nth($values, 3), -2), true);
        @include assert-equal(_includes($collection, nth($values, 2), -2), true);
      }

      @include test('should work with #{$key} and negative from-index <= negative collection length') {
        @include assert-equal(_includes($collection, nth($values, 1), -4), true);
        @include assert-equal(_includes($collection, nth($values, 1), -6), true);
      }

      @include test('should work with #{$key} and be chainable') {
        @include assert-equal(_($collection, includes if($key == 'a string', '3', 3)), true);
      }
    }

  }
  
  @include test('should work with a string literal for collection') {
    @include assert-equal(_includes('abc', 'a'), true);
    @include assert-equal(_includes('abc', 'bc'), true);
    @include assert-equal(_includes('abc', 'd'), false);
  }

  @include test('should return false for empty collections') {
    @include assert-equal(_includes(()), false);
  }

  @include test('should be aliased') {
    @include assert-equal(_contains('abc', 'a'), _includes('abc', 'a'));
    @include assert-equal(_include('abc', 'a'), _includes('abc', 'a'));
  }
}

@function test-index-by-1($value, $args...) {
    @return $value > 1;
}
@include test-module('_index-by') {
    @include test('should use _identity when iteratee is nullish') {
        $list: 4 6 6;

        @include assert-equal(_index-by($list, null), (4: 4, 6: 6));
        @include assert-equal(_index-by($list), (4: 4, 6: 6));
    }

    @include test('should work with a _pluck style iteratee') {
        $list: ('a': 'foo', 'b': 1) ('a': 'bar', 'b': 1) ('a': 'baz', 'b': 2);

        @include assert-equal(_index-by($list, 'b'), (1: ("a": "bar", "b": 1), 2: ("a": "baz", "b": 2)));
    }

    @include test('should work with a number for iteratee') {
        $list: (1 'a', 2 'a', 2 'b');

        @include assert-equal(_index-by($list, 1), (1: 1 'a', 2: 2 'b'));
        @include assert-equal(_index-by($list, 2), ('a': 2 'a', 'b': 2 'b'));
    }

    @include test('should work with map for collection') {
        $map: ('a': 4.2, 'b': 6.1, 'c': 6.4);

        @include assert-equal(_index-by($map, test-floor), (4: 4.2, 6: 6.4));
    }

    @include test('should work in a lazy chain sequence') {
        $list: 1 2 1 3;

        $actual: _($list, index-by _identity, filter test-index-by-1, take);

        @include assert-true(test-lists-equal($actual, (2,)));
    }
}

@include test-module('_index-of') {
    $list: 1 2 3 1 2 3;

    @include test('should return the index of the first matched value') {
        @include assert-equal(_index-of($list, 3), 3);
    }

    @include test('should work with a positive from-index') {
        @include assert-equal(_index-of($list, 1, 2), 4);
    }

    @include test('should work with from-index >= list length') {
        $values: 6 8 pow(2, 32);

        @each $value in $values {
            @include assert-equal(_index-of($list, 1, $value), -1);
        }
    }

    @include test('should treat falsey from-index values as 0') {
        @each $value in $test-falsey {
            @include assert-equal(_index-of($list, 1, $value), 1);
        }
    }

    @include test('should work with a negative from-index') {
        @include assert-equal(_index-of($list, 2, -3), 5);
    }

    @include test('should work with a negative from-index <= -list length') {
        @each $value in -6 -8 (pow(2, 32) * -1) {
            @include assert-equal(_index-of($list, 1, $value), 1);
        }
    }
}

@function test-initial-1($value, $args...) {
    @return $value < 3;
}
@include test-module('_initial') {
    $list: 1 2 3;

    @include test('should accept a falsey list argument') {
        @each $value in $test-falsey {
            @include assert-true(test-lists-equal(_initial($value), ()));
        }
    }

    @include test('should exclude last element') {
        @include assert-true(test-lists-equal(_initial($list), 1 2));
    }

    @include test('should return an empty list when querying empty lists') {
        @include assert-true(test-lists-equal(_initial(()), ()));
    }

    @include test('should work as an iteratee for _map') {
        $list: (1 2 3, 4 5 6, 7 8 9);

        @include assert-true(test-lists-equal(_map($list, _initial), (1 2, 4 5, 7 8)));
    }

    @include test('should work in a lazy chain sequence') {
        $list: 1 2 3;

        @include assert-true(test-lists-equal(_($list, filter test-initial-1, initial), (1,)));
    }
}

@include test-module('_intersection') {
    @include test('should return the intersection of the given lists') {
        @include assert-true(test-lists-equal(_intersection(1 2 3, 5 2 1 4, 2 1), 1 2));
    }

    @include test('should return a list of unique values') {
        $list: 1 1 3 2 2;

        @include assert-true(test-lists-equal(_intersection($list, 5 2 2 1 4, 2 1 1), 1 2));
        @include assert-true(test-lists-equal(_intersection($list), 1 3 2));
    }

    @include test('should work with arglists') {
        @include assert-true(test-lists-equal(_intersection(test-args(1, 2, 3), 2 3 4), 2 3));
    }

    @include test('should ignore values that are not lists or arglists') {
        $list: 0 1 null 3;
        $args: test-args(1, 2, 3);

        @include assert-true(test-lists-equal(_intersection($list, 3, null, (0: 1)), $list));
        @include assert-true(test-lists-equal(_intersection(null, $list, null, 2 1), (1,)));
        @include assert-true(test-lists-equal(_intersection(null, $list, null, $args), 1 3));
    }

    @include test('should be chainable') {
        @include assert-true(test-lists-equal(_(1 2 3, map test-square, intersection (9 4 7)), 4 9));
    }
}

@include test-module('_invert') {
    @include test('should invert a map') {
        $map: ('a': 1, 'b': 2);
        $actual: _invert($map);

        @include assert-equal($actual, (1: 'a', 2: 'b'));
        @include assert-equal(_invert($actual), $map);
    }

    @include test('should accept a multi-value flag') {
        $map: ('a': 1, 'b': 2, 'c': 1);

        @include assert-equal(_invert($map, true), (1: ('a', 'c'), 2: ('b',)));
    }

    @include test('should work as iteratee for _map') {
        $map: ('a': 1, 'b': 2, 'c': 1);
        $inverted: (1: 'c', 2: 'b');
        $actual: _map($map $map $map, _invert);

        @include assert-equal($actual, $inverted $inverted $inverted);
    }

    @include test('should be chainable') {
        $map: ('a': 1, 'b': 2, 'c': 1);
        $actual: _($map, map-values test-square, invert true);

        @include assert-equal($actual, (1: ('a', 'c'), 4: ('b',)));
    }
}

@include test-module('_invoke') {
    @include test('should invoke a function per item in list') {
        $list: 1 2 3;

        @include assert-equal(_invoke($list, test-square), 1 4 9);
    }

    @include test('should work with a map for collection') {
        $map: ('a': 1, 'b': 2, 'c': 3);

        @include assert-equal(_invoke($map, test-square), 1 4 9);
    }

    @include test('should treat number values for collection as empty') {
        @include assert-equal(_invoke(1), ());
    }
}

@include test-module('_is-arglist') {
    @include test('should return true for arglists') {
        @include assert-equal(_is-arglist(test-args(1, 2, 3)), true);
    }

    @include test('should return false for non arglists') {
        @each $value in join($test-falsey, (1 2 3) ('a': 1) 'abc') {
            @include assert-equal(_is-arglist($value), false);
        }
    }
}

@include test-module('_is-list') {
    @include test('should return true for lists') {
        @include assert-equal(_is-list(1 2 3), true);
        @include assert-equal(_is-list((1, 2, 3)), true);
    }

    @include test('should return false for non lists') {
        @each $value in join($test-falsey, test-args(1, 2, 3) ('a': 1) 'abc') {
            @include assert-equal(_is-list($value), false);
        }
    }
}

@include test-module('_is-boolean') {
    @include test('should return true for booleans') {
        @include assert-equal(_is-boolean(true), true);
        @include assert-equal(_is-boolean(false), true);
        @include assert-equal(_is-boolean(1 == 2), true);
        @include assert-equal(_is-boolean(1 + 1 == 2), true);
    }

    @include test('should return false for non booleans') {
        @each $value in 3, 'true', 'false', (true, false), (true: false) {
            @include assert-equal(_is-boolean($value), false);
        }
    }
}

@include test-module('_is-empty') {
    @include test('should return true for empty lists') {
        @include assert-equal(_is-empty(()), true);
        @include assert-equal(_is-empty(test-args()), true);

    }

    @include test('should return false for non empty lists') {
        @each $value in (0,), ('a': 0), 'a', test-args('a') {
            @include assert-equal(_is-empty($value), false);
        }
    }
}

@include test-module('_is-equal') {
    @include test('should perform comparisons between primitive values') {    
        $pairs: (
            (1, 1, true), (1, '1', false), (1, 2, false),
            (0, 0, true), (0, '0', false), (0, null, false),
            ('a', 'a', true), ('a', a, true), (a, a, true), ('a', 'b', false), ('a', ('a',), false),
            (true, true, true), (true, 1, false), (true, 'a', false),
            (false, false, true), (false, 0, false), (false, '', false),
            (null, null, true), (null, (), false), (null, '', false)
        );

        @each $pair in $pairs {
            @include assert-equal(_is-equal(nth($pair, 1), nth($pair, 2)), nth($pair, 3),
                'values #{inspect(nth($pair, 1))} == #{inspect(nth($pair, 2))} should equal #{nth($pair, 3)}');
        }
    }

    @include test('should perform comparisons between lists') {
        $list1: true null 1 'a' ('b': 2) #112233;
        $list2: true null 1 'a' ('b': 2) #112233;

        @include assert-equal(_is-equal($list1, $list2), true);

        @include assert-equal(_is-equal(1 2 3, 3 2 1), false);
    }

    @include test('should perform comparisons between plain maps') {
        $map1: ('a': true, 'b': null, 'c': 1, 'd': 'a', 'e': false);
        $map2: ('a': true, 'b': null, 'c': 1, 'd': 'a', 'e': false);

        @include assert-equal(_is-equal($map1, $map2), true);

        $map1: ('a': 1, 'b': 2, 'c': 3);
        $map2: ('a': 3, 'b': 2, 'c': 1);

        @include assert-equal(_is-equal($map1, $map2), false);

        $map1: ('a': 1, 'b': 2, 'c': 3);
        $map2: ('d': 1, 'e': 2, 'f': 3);

        @include assert-equal(_is-equal($map1, $map2), false);

        $map1: ('a': 1, 'b': 2);
        $map2: ('a': 1, 'b': 2, 'c': 3);

        @include assert-equal(_is-equal($map1, $map2), false);

        $map1: ('a': 1, 'b': 2, 'c': 3);
        $map2: ('c': 3, 'b': 2, 'a': 1);

        @include assert-equal(_is-equal($map1, $map2), true);
    }

    @include test('should perform comparisons of nested maps') {
        $map1: (
            'a': 1 2 3,
            'b': true,
            'c': 1,
            'd': 'a',
            'e': (
                'f': 'a' 'b' 'c',
                'g': false,
                'h': _noop,
                'j': 'a'
            )
        );

        $map2: (
            'a': 1 2 3,
            'b': not false,
            'c': 3 - 2,
            'd': a,
            'e': (
                'f': 'a' 'b' 'c',
                'g': 1 == 2,
                'h': '_noop',
                'j': 'a'
            )
        );

        @include assert-equal(_is-equal($map1, $map2), true);
    }

    @include test('should handle comparisons if customizer returns null') {
        @include assert-equal(_is-equal('a', 'a', _noop), true);
    }

    @include test('should return a boolean value even if customizer does not') {
        @include assert-equal(_is-equal('a', 'a', _constant('a')), true);
    }

    @include test('should work as an iteratee for _every') {
        @include assert-equal(_every(1 1 1, _partial(_is-equal, 1)), true);
    }

    @include test('should be chainable') {
        $actual: _('a', is-equal 'a');

        @include assert-equal($actual, true);
    }
}

@include test-module('_is-function') {
    @include test('should return true for functions') {
        @include assert-equal(_is-function(_), true);
        @include assert-equal(_is-function(to-upper-case), true);
        @include assert-equal(_is-function(_partial), true);
    }

    @include test('should return false for non-functions') {
        @each $value in $test-falsey {
            @include assert-equal(_is-function($value), false);
        }
    }

    @include test('should return true for scoped, non-native-callable functions') {
        $scoped-function: _partial(min, 3);

        @include assert-equal(_is-function($scoped-function), true);
    }
}

@include test-module('_is-match') {
    @include test('should perform a deep comparison between map and source') {
        $map: ('a': 1, 'b': 2, 'c': 3);

        @include assert-equal(_is-match($map, ('a': 1)), true);
        @include assert-equal(_is-match($map, ('b': 1)), false);
        @include assert-equal(_is-match($map, ('a': 1, 'c': 3)), true);
        @include assert-equal(_is-match($map, ('c': 3, 'd': 4)), false);

        $map: ('a': ('b': ('c': 1, 'd': 2), 'e': 3), 'f': 4);
        @include assert-equal(_is-match($map, ('a': ('b': ('c': 1)))), true);
    }

    @include test('should compare a variety of source values') {
        $map1: ('a': false, 'b': true, 'c': '3', 'd': 4, 'e': (5,), 'f': ('g': 6));
        $map2: ('a': 0, 'b': 1, 'c': 3, 'd': '4', 'e': ('5',), 'f': ('g': '6'));

        @include assert-equal(_is-match($map1, $map1), true);
        @include assert-equal(_is-match($map1, $map2), false);
    }

    @include test('should return true when comparing an empty source') {
        $map: ('a': 1);

        @include assert-equal(_is-match($map, ()), true);
    }

    @include test('should return true when comparing a source of empty lists and maps') {
        $maps: (('a': (1,), 'b': ('c': 1)), ('a': 2 3, 'b': ('d': 2)));
        $source: ('a': (), 'b': ());

        @each $map in $maps {
            @include assert-equal(__is-match($map, $source), true);
        }
    }

    @include test('should return false for falsey map values') {
        @each $value in $test-falsey {
            @include assert-equal(_is-match($value, ('a': 1)), false);
        }
    }

    @include test('should return true when comparing an empty source to a falsey map') {
        @each $value in $test-falsey {
            @include assert-equal(_is-match($value, ()), true);
        }
    }

    @include test('should search lists of source for values') {
        $maps: (('a': ('b',)), ('a': ('c', 'd')));
        $source: ('a': ('d',));
        $actual: ();

        @each $map in $maps {
            @if _is-match($map, $source) {
                $actual: append($actual, $map);
            }
        }

        @include assert-true(test-lists-equal($actual, (nth($maps, 2),)));

        $source: ('a': ('d', 'b'));
        $actual: ();

        @each $map in $maps {
            @if _is-match($map, $source) {
                $actual: append($actual, $map);
            }
        }

        @include assert-equal($actual, ());

        $source: ('a': ('b', 'd'));
        $actual: ();

        @each $map in $maps {
            @if _is-match($map, $source) {
                $actual: append($actual, $map);
            }
        }

        @include assert-equal($actual, ());
    }

    @include test('should perform a partial comparison of all maps within lists of source') {
        $source: ('a': (('b': 1), ('b': 4, 'c': 5)));

        $maps: (
            ('a': (('b': 1, 'c': 2 ), ('b': 4, 'c': 5, 'd': 6 ))),
            ('a': (('b': 1, 'c': 2 ), ('b': 4, 'c': 6, 'd': 7 )))
        );

        $actual: ();

        @each $map in $maps {
            @if _is-match($map, $source) {
                $actual: append($actual, $map);
            }
        }

        @include assert-true(test-lists-equal($actual, (nth($maps, 1),)));
    }

    // TODO: fix and finish _is-match tests
}

@include test-module('_is-null') {
    @include test('should return true for nulls') {
        @include assert-equal(_is-null(null), true);
    }

    @include test('should return false for non nulls') {
        @each $value in $test-falsey {
            @include assert-equal(_is-null($value), if(inspect($value) == 'null', true, false));
        }

        @include assert-equal(_is-null(test-args()), false);
        @include assert-equal(_is-null(1 2 3), false);
        @include assert-equal(_is-null(true), false);
        @include assert-equal(_is-null(_), false);
        @include assert-equal(_is-null(1), false);
    }
}

@include test-module('_is-number') {
    @include test('should return true for numbers') {
        @include assert-equal(_is-number(0), true);
        @include assert-equal(_is-number(999999), true);
        @include assert-equal(_is-number(-99999.5), true);
    }

    @include test('should return true for numbers with units') {
        @each $value in 1px  1cm  1mm  1%  1ch  1pc  1in  1em  1rem  1pt  1pc  1ex  1vw  1vh  1vmin  1vmax {
            @include assert-equal(_is-number($value), true);
        }
    }


    @include test('should return false for non-numbers') {
        @each $value in $test-falsey {
            @include assert-equal(_is-number($value), $value == 0);
        }
    }
}

@include test-module('_is-map') {
    @include test('should return true for maps') {
        $map: ('a': 1, 'b': 2);
        $empty-map: map-remove(('a': 1), 'a');
        $set-map: map-merge((), ('a': 3));

        @include assert-equal(_is-map($map), true);
        @include assert-equal(_is-map($empty-map), true);
        @include assert-equal(_is-map($set-map), true);
    }

    @include test('should return false for non maps') {
        @each $value in $test-falsey {
            @include assert-equal(_is-map($value), false);
        }
    }
}

@function NonPlainMap($foo) {
    @return ('foo': $foo);
}
@include test-module('_is-plain-map') {
    @include test('should detect plain maps') {
        $plain-map: ('a': 1, 'b': 2);
        $empty-map: map-remove(('a': 1), 'a');
        $set-map: map-merge((), ('a': 3));

        @include assert-equal(_is-plain-map($plain-map), true);
        @include assert-equal(_is-plain-map($empty-map), true);
        @include assert-equal(_is-plain-map($set-map), true);
    }

    @include test('should return false for constructed maps') {
        $constructed-map: __new(NonPlainMap, ('foo': 'bar'));

        @include assert-equal(_is-plain-map($constructed-map), false);
    }

    @include test('should return false for non maps') {
        @each $value in $test-falsey {
            @include assert-equal(_is-plain-map($value), false);
        }
    }
}

@include test-module('_is-string') {
    @include test('should return true for quoted strings') {
        $string: 'I am a quoted string';

        @include assert-equal(_is-string($string), true);

        $string: "I am a double quoted string";

        @include assert-equal(_is-string($string), true);

        $string: 'green';

        @include assert-equal(_is-string($string), true);

        $string: unquote('green');

        @include assert-equal(_is-string($string), true);
    }

    @include test('should return true for unquoted strings') {
        $string: foobar;

        @include assert-equal(_is-string($string), true);

        $string: unquote('foo bar baz quo');

        @include assert-equal(_is-string($string), true);
    }

    @include test('should return true for empty strings') {
        $string: '';

        @include assert-equal(_is-string($string), true);

        $string: unquote('');

        @include assert-equal(_is-string($string), true);
    }

    @include test('should return false for colors') {
        $string: green;

        @include assert-equal(_is-string($string), false);

        $string: #ee5566;

        @include assert-equal(_is-string($string), false);
    }

    @include test('should return false for non strings') {
        @each $value in $test-falsey {
            @include assert-equal(_is-string($value), $value == '');
        }
    }
}

@function TestKeysMap() {
    @return ('foo': 'bar');
}
@include test-module('keys methods') {
    @each $method-name in 'keys', 'keys-in' {
        $args: test-args(1, 2, 3);
        $func: unquote('_#{$method-name}');
        $is-keys: $method-name == 'keys';

        @include test('#{$func} should return the keys of a map') {
            @include assert-equal(_call($func, null, ('a': 1, 'b': 1)), 'a' 'b');
        }

        @include test('#{$func} should return an empty list for null values') {
            @include assert-equal(_call($func, null, null), ());

            @include assert-equal(_call($func, null), ());
        }

        @include test('#{$func} should work with strings') {
            @include assert-equal(_call($func, null, 'abc'), 1 2 3);
        }

        @include test('#{$func} should work with lists') {
            @include assert-equal(_call($func, null, (2,4,6)), 1 2 3);
        }

        @include test('#{$func} should skip meta properties of constructed maps') {
            $test-map: __new(TestKeysMap);

            @include assert-true(test-lists-equal(_call($func, null, $test-map), ('foo',)));
        }
    }
}

@include test-module('_last') {
    $list: 1 2 3;

    @include test('should return the last element') {
        @include assert-equal(_last($list), 3);
    }

    @include test('should return null when querying empty lists') {
        $list: ();

        @include assert-equal(_last($list), null);
    }

    @include test('should work as an iteratee for _map') {
        $list: (1 2 3, 4 5 6, 7 8 9);
        $actual: _map($list, _last);

        @include assert-equal($actual, 3 6 9);
    }

    @include test('should work in a lazy chain sequence') {
        $list: 1 2 3 4;

        $actual: _($list, filter test-is-even, last);

        @include assert-equal($actual, 4);
    }
}

@include test-module('_last-index-of') {
    $list: 1 2 3 1 2 3;

    @include test('should return the index of the last matched value') {
        @include assert-equal(_last-index-of($list, 3), 6);
    }

    @include test('should work with a positive from-index') {
        @include assert-equal(_last-index-of($list, 1, 3), 1);
    }

    @include test('should work with from-index >= list length') {
        $values: 6, 8, pow(2, 32), 9999;

        @each $value in $values {
            @include assert-equal(_last-index-of($list, null, $value), -1);
            @include assert-equal(_last-index-of($list, 1, $value), 4);
        }
    }

    @include test('should treat falsey from-index values, except 0, as list length') {
        @each $value in $test-falsey {
            @include assert-equal(_last-index-of($list, 3, $value), if($value == 0, -1, 6));
        }
    }

    @include test('should work with a negative from-index') {
        @include assert-equal(_last-index-of($list, 2, -3), 2);
    }

    @include test('should work with a negative from-index <= (negative) list length') {
        $values: -6, -8, -9999;

        @each $value in $values {
            @include assert-equal(_last-index-of($list, 1, $value), 1);
        }
    }
}

@include test-module('index-of methods') {
    @each $method-name in 'index-of', 'last-index-of' {
        $func: unquote('_#{$method-name}');

        @include test('#{$func} should accept falsey list argument') {
            @each $value in $test-falsey {
                @include assert-equal(_call($func, null, $value), -1);
            }
        }

        @include test('#{$func} should return -1 for an unmatched value') {
            $list: 1 2 3;
            $empty: ();

            @include assert-equal(_call($func, null, $list, 4), -1);
            @include assert-equal(_call($func, null, $list, 4, true), -1);

            @include assert-equal(_call($func, null, $empty, null), -1);
            @include assert-equal(_call($func, null, $empty, null, true), -1);
        }

        @include test('#{$func} should not match values on empty lists') {
            $list: ();

            @include assert-equal(_call($func, null, $list, null), -1);
            @include assert-equal(_call($func, null, $list, 0), -1);
        }
    }
}

@include test-module('_map') {
    $list: 1 2 3;

    @include test('should work with a _pluck style iteratee') {
        $maps: (('a': 'x'), ('a': 'y'));

        @include assert-equal(_map($maps, 'a'), 'x' 'y');
    }

    @include test('should work with a map with no iteratee') {
        @include assert-equal(_map(('a': 1, 'b': 2, 'c': 3)), $list);
    }

    @include test('should accept a falsey collection argument') {
        @each $value in $test-falsey {
            @include assert-equal(_map($value), ());
        }
    }

    @include test('should treat number values for collection as empty') {
        @include assert-equal(_map(1), ());
    }

    @include test('should be chainable') {
        $list: 1 2 3 4;

        $actual: _($list, filter test-is-even, map test-square);

        @include assert-equal($actual, 4 16);
    }

    @include test('should work with shifted argument syntax for function') {
        $lists: 1 2 3, 2 1 3, 3 1 2;

        $actual: _map($lists, index 2);

        @include assert-equal($actual, 2 1 3);
    }

    @include test('should be aliased') {
        @include assert-equal(_map($list, test-square), _collect($list, test-square))
    }
}

@include test-module('_map-values') {
    $map: ('a': 1, 'b': 2, 'c': 3);

    @include test('should work with a _pluck style iteratee') {
        $actual: _map-values(('a': ('b': 1)), 'b');

        @include assert-equal($actual, ('a': 1));
    }

    @include test('should work on a map with no iteratee') {
        @include assert-equal(_map-values($map), $map);
    }

    @include test('should accept a falsey map argument') {
        @each $value in $test-falsey {
            @include assert-equal(_map-values($value), ());
        }
    }

    @include test('should be chainable') {
        $actual: _($map, map-values test-square);

        @include assert-equal($actual, ('a': 1, 'b': 4, 'c': 9));
    }

    @include test('should work with shifted argument syntax for function') {
        $colors: ('a': #111, 'b': #222, 'c': #333);
        $actual: _map-values($colors, lighten 10%);

        @include assert-equal($actual, ('a': #2b2b2b, 'b': #3c3c3c, 'c': #4d4d4d));
    }
}

@include test-module('_matches') {
    @include test('should create a function that performs a deep comparison between a given map and source') {
        $map: ('a': 1, 'b': 2, 'c': 3);
        $matches: _matches(('a': 1));

        @include assert-equal(_call($matches, null, $map), true);
        @include assert-equal(_call($matches, null, ('b': 1)), false);
        @include assert-equal(_call($matches, null, ('a': 1, 'c': 3)), true);
        @include assert-equal(_call($matches, null, ('c': 3, 'd': 4)), false);

        $map: ('a': ('b': ('c': 1, 'd': 2), 'e': 3), 'f': 4);
        $matches: _matches(('a': ('b': ('c': 1))));

        @include assert-equal(_call($matches, null, $map), true, 'deep');
    }

    @include test('should compare a variety of source values') {
        $map1: ('a': false, 'b': true, 'c': '3', 'd': 4, 'e': (5,), 'f': ('g': 6));
        $map2: ('a': 0, 'b': 1, 'c': 3, 'd': '4', 'e': ('5',), 'f': ('g': '6'));

        $matches: _matches($map1);

        @include assert-equal(_call($matches, null, $map1), true);
        @include assert-equal(_call($matches, null, $map2), false);
    }

    @include test('should return true when comparing an empty source') {
        $map: ('a': 1);

        $matches: _matches(());

        @include assert-equal(_call($matches, null, $map), true);
    }

    @include test('should return true when comparing a source of empty lists and maps') {
        $maps: (('a': (1,), 'b': ('c': 1)), ('a': 2 3, 'b': ('d': 2)));
        $matches: _matches(('a': (), 'b': ()));
        $actual: _filter($maps, $matches);

        @include assert-true(test-lists-equal($actual, $maps));
    }

    // @include test('should not error for falsey map values') {
    //     $matches: _matches(('a': 1));

    //     @each $value in $test-falsey {
    //         @debug $value;
    //         @include assert-equal(_call($matches, null, $value), false, inspect($value));
    //     }
    // }

    // @include test('should return true when comparing an empty source to a falsey map') {
    //     $matches: _matches(());

    //     @each $value in $test-falsey {
    //         @include assert-equal(_call($matches, null, $value), true);
    //     }
    // }

    @include test('should search lists of source for values') {
        $maps: ('a': ('b',)), ('a': ('c', 'd'));
        $matches: _matches(('a': ('d',)));
        $actual: _filter($maps, $matches);

        @include assert-true(test-lists-equal($actual, (nth($maps, 2),)));

        $matches: _matches(('a': ('b', 'd')));
        $actual: _filter($maps, $matches);

        @include assert-true(test-lists-equal($actual, ()));

        $matches: _matches(('a': ('d', 'b')));
        $actual: _filter($maps, $matches);

        @include assert-true(test-lists-equal($actual, ()));
    }

    @include test('should perform a partial comparison of all maps within lists of source') {
        $maps: (
            ('a': (('b': 1, 'c': 2 ), ('b': 4, 'c': 5, 'd': 6 ))),
            ('a': (('b': 1, 'c': 2 ), ('b': 4, 'c': 6, 'd': 7 )))
        );

        $matches: _matches(('a': (('b': 1), ('b': 4, 'c': 5))));
        $actual: _filter($maps, $matches);

        @include assert-true(test-lists-equal($actual, (nth($maps, 1),)));
    }
}

@include test-module('_max') {
    @include test('should return the largest value from a collection') {
        @include assert-equal(_max(1 2 3), 3);
    }

    @include test('should return -infinity for empty collections') {
        @include assert-equal(_max(()), __const('NEGATIVE_INFINITY'));
    }

    @include test('should return -infinity for non-numeric collection values') {
        $collections: (true, false), (true: true, false: false);

        @each $collection in $collections {
            @include assert-equal(_max($collection), __const('NEGATIVE_INFINITY'), inspect($collection));
        }
    }
}

@include test-module('_merge') {
  @include test('should merge source into the destination map') {
    @include assert-equal(_merge((a:1),(b:2)), (a:1,b:2));

    $names: (
      'characters': (
        ('name': 'barney'),
        ('name': 'fred')
      )
    );

    $ages: (
      'characters': (
        ('age': 36),
        ('age': 40)
      )
    );

    $heights: (
      'characters': (
        ('height': '5ft4'),
        ('height': '5ft5')
      )
    );

    $expected: (
      'characters': (
        ('name': 'barney', 'age': 36, 'height': '5ft4'),
        ('name': 'fred', 'age': 40, 'height': '5ft5')
      )
    );

    @include assert-equal(_merge($names, $ages, $heights), $expected);
  }

  @include test('should merge arglists') {
    $map1: ('value': test-args(1, 2, 3));
    $map2: ('value': (4: 4));
    $expected: ('value': (1: 1, 2: 2, 3: 3, 4: 4));

    @include assert-equal(_merge($map1, $map2), $expected);
  }

  @include test('should work with four arguments') {
    $expected: ('a': 4);

    @include assert-equal(_merge(('a': 1), ('a': 2), ('a': 3), $expected), $expected);
  }

  @include test('should assign null values') {
    $actual: _merge(('a': 1), ('a': null));

    @include assert-equal(__get($actual, 'a'), null);
  }
}

@include test-module('Sassdash') {
  @include test('_min') {
    @include assert-equal(_min(1 2 3), 1,
      'should return the smallest value from a collection');

    @include assert-equal(_min(()), __const('POSITIVE_INFINITY'),
      'should return Infinity for empty collections');

    @include assert-equal(_min(('a' 'b') ('a': 'a', 'b': 'b')), __const('POSITIVE_INFINITY'),
      'should return Infinity for non-numeric collection items');
  }
}

@function test-maxmin-1($num, $args...) {
  @return -$num;
}
@include test-module('Sassdash') {
  @include test('_max and _min') {
    @each $method-name in 'max', 'min' {
      $list: 1 2 3;
      $func: unquote('_#{$method-name}');
      $is-max: $method-name == 'max';

      @include assert-equal(_call($func, null, $list, test-maxmin-1), if($is-max, 1, 3),
        'should work with an iteratee argument');

      $maps: (('a': 2), ('a': 3), ('a': 1));
      $actual: _call($func, null, $maps, 'a');

      @include assert-equal($actual, nth($maps, if($is-max, 2, 3)),
        'should work with _pluck style iteratee');

      $actual: _call($func, null, ('a': 1, 'b': 2, 'c': 3));

      @include assert-equal($actual, if($is-max, 3, 1),
        'should iterate a map');

      @include assert-equal(_call($func, null, 'abc'), if($is-max, 'c', 'a'),
        'should iterate a string');

      $list: (2 3 1, 5 6 4, 8 9 7);
      $actual: _map($list, $func);

      @include assert-equal($actual, if($is-max, 3 6 9, 1 4 7),
        '#{$func} should work as an iteratee for _map');

      @include assert-equal(_map('abc', $func), 'a' 'b' 'c',
        '#{$func} should work as an iteratee for _map');

      @include assert-equal(_((40,), $method-name), 40,
        'should work when chaining on a list with only one value');
    }
  }
}

@include test-module('Sassdash') {
  @include test('_negate') {
    $negate: _negate(test-is-even);

    @include assert-equal(_call($negate, null, 1), true,
      'should create a function that negates the result of func');

    @include assert-equal(_call($negate, null, 2), false,
      'should create a function that negates the result of func');
  }
}

@include test-module('Sassdash') {
  @include test('_noop') {
    @include assert-equal(_noop(1, 2, 3), null,
      'should return null');
  }
}

@include test-module('Sassdash') {
  @include test('_omit') {
    $map: ('a': 1, 'b': 2, 'c': 3);
    $expected: ('b': 2);

    @include assert-equal(_omit($map, 'a'), ('b': 2, 'c': 3),
      'should create a map with omitted properties');

    @include assert-equal(_omit($map, 'a', 'c'), $expected,
      'should create a map with omitted properties');

    @include assert-equal(_omit($map, 'a' 'c'), $expected,
      'should support picking a list of properties');

    @include assert-equal(_omit($map, ('a',), 'c'), $expected,
      'should support picking a list of properties and individual properties');

    @include assert-equal(_omit(null, 'test'), (),
      'should return an empty map when map is null');

    $args: test-args('a', 'c');

    @include assert-equal(_omit($map, $args), $expected,
      'should work with arglists as secondary arguments');

    @include assert-equal(_omit(1 2 3, 1, 3), (2: 2),
      'should work with a list map argument');
    
    @include assert-equal(_omit(('a': 1,'b': 2,'c': 3,'d': 4,'e': 5), test-is-even), ('a': 1, 'c': 3, 'e': 5),
      'should work with a predicate argument');
  }
}

@include test-module('Sassdash') {
  @include test('_once') {
    $once: _once(test-square);
    $actual: _call($once, null, 2);

    @include assert-equal($actual, 4,
      'should invoke func once');

    $actual: _call($once, null, 2);

    @include assert-equal($actual, null,
      'should invoke func once');
  }
}

@include test-module('Sassdash') {
  @include test('_pad') {
    @include assert-equal(_pad('abc', 9), '   abc   ',
      'should pad a string to a given length');

    @include assert-equal(_pad('abc', 8), '  abc   ',
      'should truncate pad characters to fit the pad length');

    @include assert-equal(_pad('abc', 8, '_-'), '_-abc_-_',
      'should truncate pad characters to fit the pad length');

    @include assert-equal(_pad(123, 9), '   123   ',
      'should coerce to a string');
  }

  @include test('_pad-left') {
    @include assert-equal(_pad-left('abc', 9), '      abc',
      'should pad a string to a given length');

    @include assert-equal(_pad-left('abc', 6, '_-'), '_-_abc',
      'should truncate pad characters to fit the pad length');

    @include assert-equal(_pad-left(123, 4), ' 123',
      'should coerce to a string');
  }

  @include test('_pad-right') {
    @include assert-equal(_pad-right('abc', 9), 'abc      ',
      'should pad a string to a given length');

    @include assert-equal(_pad-right('abc', 6, '_-'), 'abc_-_',
      'should truncate pad characters to fit the pad length');

    @include assert-equal(_pad-right(123, 4), '123 ',
      'should coerce to a string');
  }

  @include test('_pad methods') {
    @each $method-name in 'pad', 'pad-left', 'pad-right' {
      $func: unquote('_#{$method-name}');
      $is-pad-left: $method-name == 'pad-left';

      @include assert-equal(_call($func, null, 'abc', 2), 'abc',
        'should not pad if string is >= length');

      @include assert-equal(_call($func, null, 'abc', 3), 'abc',
        'should not pad if string is >= length');

      @include assert-equal(_call($func, null, 'abc', 0), 'abc',
        'should treat negative length as 0');

      @include assert-equal(_call($func, null, 'abc', -3), 'abc',
        'should treat negative length as 0');

      @include assert-equal(_call($func, null, null, 0, null), '',
        'should return an empty string when provided null or empty string and chars');

      @include assert-equal(_call($func, null, null, 0, '_-'), '',
        'should return an empty string when provided null or empty string and chars');

      @include assert-equal(_call($func, null, '', 0, null), '',
        'should return an empty string when provided null or empty string and chars');

      @include assert-equal(_call($func, null, '', 0, '_-'), '',
        'should return an empty string when provided null or empty string and chars');

      @include assert-equal(_call($func, null, 'abc', 6, null), 'abc',
        'should work with null or empty string for chars');

      @include assert-equal(_call($func, null, 'abc', 6, ''), 'abc',
        'should work with null or empty string for chars');
    }
  }
}

@include test-module('Sassdash') {
  @include test('_pairs') {
    $map: ('a': 1, 'b': 2);

    @include assert-true(test-lists-equal(_pairs($map), (('a', 1), ('b', 2))),
      'should create a 2d list of key-value pairs');
  }
}

@include test-module('_parse-float') {
    @include test('should parse an integer') {
        @include assert-equal(_parse-float('4'), 4);
        @include assert-equal(_parse-float('0'), 0);
        @include assert-equal(_parse-float('123456'), 123456);
    }

    @include test('should parse a number with a radix') {
        @include assert-equal(_parse-float('123.4567'), 123.4567);
    }

    @include test('should parse a number with a radix < 1') {
        @include assert-equal(_parse-float('0.123'), 0.123);

        @include assert-equal(_parse-float('.123'), 0.123);
    }

    @include test('should parse negative numbers') {
        @include assert-equal(_parse-float('-42'), -42);
        @include assert-equal(_parse-float('-12.345'), -12.345);
        @include assert-equal(_parse-float('-0.123'), -0.123);
        @include assert-equal(_parse-float('-.123'), -0.123);
    }

    @include test('should trim string before parsing') {
        @include assert-equal(_parse-float('   123.456'), 123.456);
        @include assert-equal(_parse-float('123.456   '), 123.456);
        @include assert-equal(_parse-float('   123.456   '), 123.456);
    }

    @include test('should provide the correct unit for a parsed number') {
      @include assert-equal(_parse-float('123rem'), 123rem);
      @include assert-equal(_parse-float('123%'), 123%);
      @include assert-equal(_parse-float('   123em'), 123em);
      @include assert-equal(_parse-float('123px   '), 123px);
    }

    @include test('should ignore non-valid units') {
      @include assert-equal(_parse-float('123fake'), 123);
    }

    @include test('should not attempt to parse non-strings') {
      @include assert-equal(_parse-float(123), 123);
      @include assert-equal(_parse-float(123.456), 123.456);
      @include assert-equal(_parse-float(#a3b2c1), #a3b2c1);
      @include assert-equal(_parse-float(1 2 3), 1 2 3);
    }
}

@include test-module('_parse-int') {
  @include test('should accept a radix argument') {
    @for $value from 2 through 37 {
      @include assert-equal(_parse-int('10', $value), $value);
    }
  }

  @include test('should use a radix of 10, for non-hexadecimals, if radix is null or 0') {
    @include assert-equal(_parse-int('10'), 10);
    @include assert-equal(_parse-int('10', 0), 10);
    @include assert-equal(_parse-int('10', 10), 10);
  }

  @include test('should use a radix of 16, for hexadecimals, if radix is 0 or null') {
    @each $string in '0x20', '0X20', '#000020', #000020 {
      @include assert-equal(_parse-int($string), 32);
      @include assert-equal(_parse-int($string, 0), 32);
      @include assert-equal(_parse-int($string, 16), 32);
    }
  }

  @include test('should use a radix of 10 for string with leading zeros') {
    @include assert-equal(_parse-int('08'), 8);
    @include assert-equal(_parse-int('08', 10), 8);
  }

  @include test('should parse strings with leading whitespace') {
    @include assert-equal(_parse-int('   123'), 123);
    @include assert-equal(_parse-int('   0x20'), 32);
  }

  @include test('should work as an iteratee for _map') {
    $actual: _map('6' '08' '10', _parse-int);

    @include assert-equal($actual, 6 8 10);

    $actual: _map('123', _parse-int);

    @include assert-equal($actual, 1 2 3);
  }
}

@function test-partial-1($a, $b) {
  @return ($a, $b);
}
@function test-partial-2($args...) {
  @return length($args);
}
@include test-module('Sassdash') {
  @include test('_partial methods') {
    @each $method-name in 'partial', 'partial-right' {
      $func: unquote('_#{$method-name}');
      $is-partial: $method-name == 'partial';

      $par: _call($func, null, _identity, 'a');

      @include assert-equal(_call($par), 'a',
        '#{$func} partially applies arguments');

      $expected: ('a', 'b');
      $par: _call($func, null, test-partial-1, 'a');

      @include assert-true(test-lists-equal(_call($par, null, 'b'), if($is-partial, $expected, __list-reverse($expected))),
        '#{$func} creates a function that can be invoked with additional arguments');

      $par: _call($func, null, test-partial-2);

      @include assert-equal(_call($par), 0,
        '#{$func} works when there are no partially applied arguments and the created function is invoked without additional arguments');

      $par: _call($func, null, _identity);

      @include assert-equal(_call($par, null, 'a'), 'a',
        '#{$func} works when there are no partially applied arguments and the created function is invoked with additional arguments');
    }
  }
}

@include test-module('Sassdash') {
  @include test('_partition') {
    $list: 1 0 1;

    @include assert-true(test-lists-equal(_partition((), _identity), ((), ())),
      'should return two groups of elements');

    @include assert-true(test-lists-equal(_partition($list, _constant(true)), ($list, ())),
      'should return two groups of elements');

    @include assert-true(test-lists-equal(_partition($list, _constant(false)), ((), $list)),
      'should return two groups of elements');

    $expected: (1 1), (0,);

    @include assert-true(test-lists-equal(_partition($list, null), $expected),
      'should use _identity when predicate is nullish');

    @include assert-true(test-lists-equal(_partition($list), $expected),
      'should use _identity when predicate is nullish');

    // todo: should support the this-arg argument

    $maps: (('a': 1), ('a': 1), ('b': 2));
    $expected: _slice($maps, 0, 2), _slice($maps, 2);

    @include assert-true(test-lists-equal(_partition($maps, 'a'), $expected),
      'should work with a _pluck style predicate');

    $list: (1 0, 0 1, 1 0);
    $expected: ((1 0, 1 0), (0 1,));

    @include assert-true(test-lists-equal(_partition($list, 1), $expected),
      'should work with a number for predicate');

    $map: ('a': 1.1, 'b': 0.2, 'c': 1.3);

    @include assert-true(test-lists-equal(_partition($map, test-floor), ((1.1, 1.3), (0.2,))),
      'should work with map for collection');
  }
}

@include test-module('Sassdash') {
  $map: ('a': 1, 'b': 2, 'c': 3);
  $expected: ('a': 1, 'c': 3);

  @include test('_pick') {  
    @include assert-equal(_pick($map, 'a'), ('a': 1),
      'should create a map of picked properties');

    @include assert-equal(_pick($map, 'a' 'c'), $expected,
      'should support picking a list of properties');

    @include assert-equal(_pick($map, ('a',), 'c'), $expected,
      'should support picking a list of properties and individual properties');

    @include assert-equal(_pick(null, 'something'), (),
      'should return an empty map when map is null');

    $args: test-args('a', 'c');
    @include assert-equal(_pick($map, $args), $expected,
      'should work with arglist as secondary arguments');

    @include assert-equal(_pick(1 2 3, 2), (2: 2),
      'should work with a list map argument');

    @include assert-equal(_pick($map, test-is-even), ('b': 2),
      'should work with a predicate argument');
  }
}

@include test-module('Sassdash') {
  @include test('_pluck') {
    $maps: (
      ('name': 'barney', 'age': 36),
      ('name': 'fred', 'age': 40)
    );

    @include assert-true(test-lists-equal(_pluck($maps, 'name'), ('barney', 'fred')),
      'should return a list of property values from each element of a collection');

    $map: ('a': (1: 'one'), 'b': (1: 'two'), 'c': (1: 'three'));

    @include assert-true(test-lists-equal(_pluck($map, 1), ('one' 'two' 'three')),
      'should work with a map for collection');

    $list: (('a': 1),);

    @include assert-true(test-lists-equal(_pluck($list, 'b'), (null,)),
      'should return null for undefined properties');

    $maps: (('a': 1), null, false, ('a': 4));

    @include assert-true(test-lists-equal(_pluck($maps, 'a'), (1 null null 4)),
      'should work with nullish elements');

    $list: (('a': 1), null, ('a': 3), ('a': 4));
    $actual: _($list, pluck 'a');

    @include assert-true(test-lists-equal($actual, 1 null 3 4),
      'should work in a lazy chain sequence');

    @include assert-true(test-lists-equal(_($list, filter _identity, pluck 'a'), 1 3 4),
      'should work in a lazy chain sequence');
  }
}

@include test-module('Sassdash') {
  @include test('_property') {
    $map: ('a': 1, 'b': 2);
    $prop: _property('a');

    @include assert-equal(_call($prop, null, $map), 1,
      'should create a function that plucks a property value of a given map');

    $prop: _property('b');

    @include assert-equal(_call($prop, null, $map), 2,
      'should create a function that plucks a property value of a given map');

    $prop: _property(2);

    @include assert-equal(_call($prop, null, 10 20 30), 20,
      'should work with non-string prop arguments');

    $prop: _property('a');

    @include assert-equal(_call($prop, null, null), null,
      'should work when map is nullish');
  }
}

@include test-module('Sassdash') {
  @include test('_pull') {
    $list: 1 200 3;

    @include assert-true(test-lists-equal(_pull($list, 1, 3), (200,)),
      'should return the modified list');
  }
}

@include test-module('Sassdash') {
  $list: null null null null null null null null null null null null null null null null null null null null;

  @include test('_rand') {
    $actual: _map($list, _rand);

    @include assert-true(test-lists-equal(__sort(_uniq($actual)), (0, 1)),
      'should return 0 or 1 when arguments are not provided');

    $min: 5;
    $max: 10;

    $is-within-range: true;

    @each $item in $list {
      $result: _rand($min, $max);
      $is-within-range: $result >= $min and $result <= $max;
    }

    @include assert-equal($is-within-range, true,
      'should support a min and max argument');

    $min: 0;
    $max: 5;

    $is-within-range: true;

    @each $item in $list {
      $result: _rand($max);
      $is-within-range: $result >= $min and $result <= $max;
    }

    @include assert-equal($is-within-range, true,
      'should support not providing a max argument');

    @include assert-equal(_rand('1', '1'), 1,
      'should coerce arguments to numbers');

    $min: 1.5;
    $max: 1.6;
    $actual: _rand($min, $max);

    @include assert-equal($actual % 1 > 0, true,
      'should support floats');

    @include assert-equal($actual >= $min and $actual <= $max, true,
      'should support floats');

    $actual: _rand(true);
    $actual: if($actual % 1 == 0, _rand(true), $actual);

    @include assert-equal($actual % 1 > 0 and $actual >= 0 and $actual <= 1, true,
      'should support providing a floating argument');

    $actual: _rand(2, true);
    $actual: if($actual % 1 == 0, _rand(2, true), $actual);

    @include assert-equal($actual % 1 > 0 and $actual >= 0 and $actual <= 2, true,
      'should support providing a floating argument');

    $actual: _rand(2, 4, true);
    $actual: if($actual % 1 == 0, _rand(2, 4, true), $actual);

    @include assert-equal($actual % 1 > 0 and $actual >= 2 and $actual <= 4, true,
      'should support providing a floating argument');

    $list: 1 2 3 4 5 6 7 8 9 10;
    $randoms: _map($list, _rand);
    $result: true;

    @each $random-index, $random-value in zip($list, $randoms) {
      $result: $result and $random-value >= 0 and $random-value <= $random-index and $random-value % 1 == 0;
    }

    @include assert-equal($result, true,
      'should work as an iteratee for _map');
  }
}

@include test-module('Sassdash') {
  @include test('_range') {
    @include assert-true(test-lists-equal(_range(4), 0 1 2 3),
      'should work with a single end argument');

    @include assert-true(test-lists-equal(_range(1, 5), 1 2 3 4),
      'should work with start and end arguments');

    @include assert-true(test-lists-equal(_range(0, 20, 5), 0 5 10 15),
      'should work with start, end, and step arguments');

    @include assert-true(test-lists-equal(_range(1, 4, 0), 1 1 1),
      'should support a step of 0');

    @include assert-true(test-lists-equal(_range(1, 5, 20), (1,)),
      'should work with a step larger than end');

    @include assert-true(test-lists-equal(_range(0, -4, -1), 0 -1 -2 -3),
      'should work with a negative step argument');

    @include assert-true(test-lists-equal(_range(21, 10, -3), 21 18 15 12),
      'should work with a negative step argument');

    @each $value in $test-falsey {
      @include assert-true(test-lists-equal(_range($value), ()),
        'should treat falsey arguments as 0');
    }

    $actual: _map(1 2 3, _range);
    $expected: (0,), (0 1), (0 1 2);

    @include assert-true(test-lists-equal($actual, $expected),
      'should work as an iteratee for _map');
  }
}

@function test-reduce-1($a, $b, $args...) {
  @return $a + $b + to-upper-case($b);
}
@include test-module('Sassdash') {
  $list: 1 2 3;

  @include test('_reduce') {  
    @include assert-equal(_reduce($list), 1,
      'should use the first element of a collection as the default accumulator');

    @include assert-equal(_reduce($list, test-add), 6,
      'should reduce a collection given an iterator');

    @include assert-equal(_reduce('abc', test-reduce-1, ''), 'aAbBcC',
      'should work with a string literal for collection');

    @include assert-equal(_foldl($list, test-add), _reduce($list, test-add),
      'should be aliased');

    @include assert-equal(_inject($list, test-add), _reduce($list, test-add),
      'should be aliased');
  }
}

@include test-module('Sassdash') {
  $list: 1 2 3;

  @include test('_reduce-right') {  
    @include assert-equal(_reduce-right($list), 3,
      'should use the last element of a collection as the default accumulator');

    @include assert-equal(_reduce-right($list, test-add), 6,
      'should reduce a collection given an iterator');

    @include assert-equal(_reduce-right('abc', test-reduce-1, ''), 'cCbBaA',
      'should work with a string literal for collection');

    @include assert-equal(_foldr($list, test-add), _reduce-right($list, test-add),
      'should be aliased');
  }
}

@include test-module('Sassdash') {
  $list: 1 2 3;

  @include test('_reduce methods') {  
    @each $method-name in 'reduce', 'reduce-right' {
      $func: unquote('_#{$method-name}');
      $is-reduce: $method-name == 'reduce';

      @include assert-equal(
        _call($func, null, 'a' 'b' 'c', test-add, ''),
        if($is-reduce, 'abc', 'cba'),
        '#{$func} should reduce a collection to a single value');

      @include assert-equal(
        _call($func, null, (), _noop),
        null,
        '#{$func} should support empty collections without an initial accumulator value');

      @include assert-equal(
        _call($func, null, (), _noop, 'x'),
        'x',
        '#{$func} should support empty collections with an initial accumulator value');
    }
  }
}

@include test-module('Sassdash') {
  @include test('_reject') {
    @include assert-equal(_reject(1 2 3, test-is-even), 1 3,
      'should return elements the predicate returns falsey for');
  }
}

@function test-filter-methods-1($value, $args...) {
  @return $value > 3;
}
@include test-module('Sassdash') {
  @include test('filter methods') {
    @each $method-name in 'filter', 'reject' {
      $func: unquote('_#{$method-name}');
      $is-filter: $method-name == 'filter';

      $maps: (('a': 0), ('a': 1));

      @include assert-true(test-lists-equal(
        _call($func, null, $maps, 'a'),
        (nth($maps, if($is-filter, 2, 1)),)),
        '#{$func} should work with a _pluck style predicate');

      @include assert-true(test-lists-equal(
        _call($func, null, $maps, nth($maps, 2)),
        (nth($maps, if($is-filter, 2, 1)),)),
        '#{$func} should work with a _where style predicate');

      $list: 1 2 3;
      $map: ('a': 1, 'b': 2, 'c': 3);

      $actual: _($list, map test-square, $method-name test-filter-methods-1);

      @include assert-true(test-lists-equal(
        $actual,
        if($is-filter, 4 9, (1,))),
        '#{$func} should work in a lazy chain sequence');

      @actual: _($map, map-values test-square, $method-name test-filter-methods-1);

      @include assert-true(test-lists-equal(
        $actual,
        if($is-filter, 4 9, (1,))),
        '#{$func} should work in a lazy chain sequence');
    }
  }
}

@include test-module('Sassdash') {
  @include test('_repeat') {
    @include assert-equal(_repeat('*', 3), '***',
      'should repeat a string n times');

    @include assert-equal(_repeat('abc', 3), 'abcabcabc',
      'should repeat a string n times');

    @include assert-equal(_repeat('abc', 0), '',
      'should return an empty string for negative n or n of 0');

    @include assert-equal(_repeat('abc', -2), '',
      'should return an empty string for negative n or n of 0');

    @include assert-equal(_repeat('abc'), '',
      'should coerce n to a number');

    @include assert-equal(_repeat('abc', '2'), 'abcabc',
      'should coerce n to a number');

    @include assert-equal(_repeat(123, '2'), '123123',
      'should coerce string to a string');
  }
}

@function test-result-1() {
  @return __this('a');
}
@include test-module('Sassdash') {
  @include test('_result') {
    $map: (
      'a': 1,
      'b': null,
      'c': test-result-1
    );

    @include assert-equal(_result($map, 'a'), 1,
      'should resolve property values');

    @include assert-equal(_result($map, 'b'), null,
      'should resolve property values');

    @include assert-equal(_result($map, 'c'), 1,
      'should resolve property values');

    @include assert-equal(_result($map, 'd'), null,
      'should resolve property values');

    @include assert-equal(_result(null, 'a'), null,
      'should return null when map is nullish');

    @include assert-equal(_result($map, 'd', 42), 42,
      'should return the specified default value for undefined properties');

    @include assert-equal(_result($map, 'd', __get($map, 'c')), 1,
      'should execute default function values');
  }
}

@include test-module('Sassdash') {
  @include test('_rest') {
    $list: 1 2 3;

    @each $value in $test-falsey {
      @include assert-equal(_rest($value), (),
        'should accept a falsey list argument');
    }

    @include assert-equal(_rest($list), 2 3,
      'should exclude the first element');

    @include assert-equal(_rest(()), (),
      'should return an empty list when querying empty lists');

    $list-list: (1 2 3, 4 5 6, 7 8 9);
    $actual: _map($list-list, _rest);

    @include assert-true(test-lists-equal($actual, (2 3, 5 6, 8 9)),
      'should work as an iteratee for _map');

    @include assert-true(test-lists-equal(_($list, rest, filter test-is-even), (2,)),
      'should work in a lazy chain sequence');

    @include assert-equal(_tail($list), _rest($list),
      'should be aliased');
  }
}

@include test-module('Sassdash') {
  @include test('_sample') {
    $list: 1 2 3;

    $actual: _sample($list);
    @include assert-equal(_includes($list, $actual), true,
      'should return a random element');

    $actual: _sample($list, 2);

    @include assert-equal(_includes($list, nth($actual, 1)) and _includes($list, nth($actual, 2)) and length($actual) == 2, true,
      'should return two random elements');

    $actual: _sample($list, length($list));

    @include assert-equal(__sort($actual), $list,
      'should contain elements of the collection');

    @each $value in $test-falsey {
      @include assert-equal(_sample((1,), $value), if($value == null, 1, ()),
        'should treat falsey n values, except null, as 0');
    }

    @each $value in 0, -1, -9999 {
      @include assert-equal(_sample($list, $value), (),
        'should return an empty list when n < 1 or NaN');
    }

    @each $value in 3, 4, pow(2, 32), 9999 {
      @include assert-equal(__sort(_sample($list, $value)), $list,
        'should return all elements when n >= list length');
    }

    @include assert-equal(_sample(()), null,
      'should return null when sampling an empty list');

    $values: (1 2 3, 4 5 6, 7 8 9);
    $actual: _map($values, _sample);

    @include assert-equal(_includes(nth($values, 1), nth($actual, 1)) and _includes(nth($values, 2), nth($actual, 2)) and _includes(nth($values, 3), nth($actual, 3)), true,
      'should work as an iteratee for _map');

    $values: ('abc', 'def', 'ghi');
    $actual: _map($values, _sample);

    @include assert-equal(_includes($values, nth($actual, 1)) and _includes($values, nth($actual, 2)) and _includes($values, nth($actual, 3)), true,
      'should work as an iteratee for _map');

    $actual: _sample('abc', 2);

    @include assert-equal(length($actual) == 2 and nth($actual, 1) != nth($actual, 2) and _includes('abc', nth($actual, 1)), true,
      'should work with a string literal for collection');
  }
}

@function test-shuffle-1($args...) {
  @return _shuffle(1 2);
}
@include test-module('Sassdash') {
  @include test('_shuffle') {
    $list: 1 2 3 4 5;
    $map: ('a': 1, 'b': 2, 'c': 3);

    @include assert-true(test-lists-equal(_shuffle($list) != $list, true),
      'should return a new list');

    @include assert-true(test-lists-equal(__sort(_shuffle($list)), $list),
      'should contain the same elements after a collection is shuffled');

    @include assert-true(test-lists-equal(length(_shuffle($map)), length($map)),
      'should contain the same elements after a collection is shuffled');

    $actual: _times(10, test-shuffle-1);

    @include assert-true(test-lists-equal(_sort-by(_uniq($actual), 1), (1 2, 2 1)),
      'should shuffle small collections');
  }
}

@include test-module('Sassdash') {
  @include test('_size') {
    $list: 1 2 3;

    @include assert-equal(_size(('one': 1, 'two': 2, 'three': 3)), 3,
      'should return the number of own enumerable properties of a map');

    @include assert-equal(_size($list), 3,
      'should return the length of a list');

    @each $value in $test-falsey {
      @include assert-equal(_size($value), 0,
        'should accept a falsey map arg');
    }

    $args: test-args(1, 2, 3);

    @include assert-equal(_size($args), 3,
      'should work with arglist object');

    @include assert-equal(_size('abc'), 3,
      'should work with a string for collection');
  }
}

@include test-module('Sassdash') {
  @include test('_slice') {
    $list: 1 2 3;

    @include assert-true(test-lists-equal(_slice($list, 1), 2 3),
      'should work with a positive start');

    @each $value in 3, 4, pow(2, 32), 9999 {
      @include assert-true(test-lists-equal(_slice($list, $value), ()),
        'should work with a start >= list length');
    }

    @each $value in $test-falsey {
      @include assert-true(test-lists-equal(_slice($list, $value), $list),
        'should treat falsey start values as 0');
    }

    @include assert-true(test-lists-equal(_slice($list, -1), (3,)),
      'should work with a negative start');

    @each $value in -3, -4, -9999 {
      @include assert-true(test-lists-equal(_slice($list, $value), $list),
        'should work with a negative start <= negative list length');
    }

    @each $value in 2, 3 {
      @include assert-true(test-lists-equal(_slice($list, $value, 2), ()),
        'should work with start >= end');
    }

    @include assert-true(test-lists-equal(_slice($list, 0, 1), (1,)),
      'should work with positive end');

    @each $value in 3, 4, pow(2, 32), 9999 {
      @include assert-true(test-lists-equal(_slice($list, 0, $value), $list),
        'should work with an end >= list length');
    }

    @each $value in $test-falsey {
      @include assert-true(test-lists-equal(_slice($list, 0, $value), ()),
        'should treat falsey end values as 0');
    }

    @include assert-true(test-lists-equal(_slice($list, 0, -1), 1 2),
      'should work with a negative end');

    @each $value in -3, -4, -9999 {
      @include assert-true(test-lists-equal(_slice($list, 0, $value), ()),
        'should work with a negative end <= negative list length');
    }

    $actual: (
      _slice($list, 0.1, 1.1),
      _slice($list, '0', 1),
      _slice($list, 0, '1'),
      _slice($list, '1'),
    );

    $expected: ((1,), (1,), (1,), (2 3));

    @include assert-true(test-lists-equal($actual, $expected),
      'should coerce start and end to integers');

    $list: ((1,), (2 3));
    $actual: _map($list, _slice);

    @include assert-true(test-lists-equal($actual, $list),
      'should work as iteratee for map');
  }
}

@include test-module('Sassdash') {
  @include test('_some') {
    @include assert-equal(_some((), _identity), false,
      'should return false for empty collections');

    @include assert-equal(_some(false 1 '', _identity), true,
      'should return true if predicate returns truthy for any element in the collection');

    @include assert-equal(_some(null 'x' 0, _identity), true,
      'should return true if predicate returns truthy for any element in the collection');

    @include assert-equal(_some(false false false, _identity), false,
      'should return false if predicate returns falsey for all elements in the collection');

    @include assert-equal(_some(null 0 '', _identity), false,
      'should return false if predicate returns falsey for all elements in the collection');

    @include assert-equal(_some(null true null, _identity), true,
      'should return true as soon as predicate returns truthy');

    $maps: (('a': 0, 'b': 0), ('a': 0, 'b': 1));

    @include assert-equal(_some($maps, 'a'), false,
      'should work with a _pluck style predicate');

    @include assert-equal(_some($maps, 'b'), true,
      'should work with a _pluck style predicate');

    @include assert-equal(_some($maps, ('a': 0)), true,
      'should work with a _where style predicate');

    @include assert-equal(_some($maps, ('b': 2)), false,
      'should work with a _where style predicate');

    @include assert-equal(_some(0 0), false,
      'should use _identity when predicate is nullish');

    @include assert-equal(_some(0 0, null), false,
      'should use _identity when predicate is nullish');

    @include assert-equal(_some(0 1), true,
      'should use _identity when predicate is nullish');

    @include assert-equal(_some(0 1, null), true,
      'should use _identity when predicate is nullish');

    @include assert-equal(_any(0 1), _some(0 1),
      'should be aliased');
  }
}

@function test-sort-by-1($a, $b, $c) {
  @return ('a': $a, 'b': $b, 'c': $c);
}
@function test-sort-by-2($map, $args...) {
  @return __get($map, 'b');
}
@function test-sort-by-3($map, $args...) {
  @return __get($map, 'a');
}
@function test-sort-by-4($value, $args...) {
  @return -1 * $value;
}
@include test-module('_sort-by') {
  $maps: (
    ( 'a': 'x', 'b': 3 ),
    ( 'a': 'y', 'b': 4 ),
    ( 'a': 'x', 'b': 1 ),
    ( 'a': 'y', 'b': 2 )
  );

  $stable-order: (
    test-sort-by-1(1, 1, 1), test-sort-by-1(1, 2, 1),
    test-sort-by-1(1, 1, 1), test-sort-by-1(1, 2, 1),
    test-sort-by-1(1, 3, 1), test-sort-by-1(1, 4, 1),
    test-sort-by-1(1, 5, 1), test-sort-by-1(1, 6, 1),
    test-sort-by-1(2, 1, 2), test-sort-by-1(2, 2, 2),
    test-sort-by-1(2, 3, 2), test-sort-by-1(2, 4, 2),
    test-sort-by-1(2, 5, 2), test-sort-by-1(2, 6, 2),
    test-sort-by-1(3, 1, 1), test-sort-by-1(3, 2, 1),
    test-sort-by-1(3, 3, 1), test-sort-by-1(3, 4, 1),
    test-sort-by-1(3, 5, 1), test-sort-by-1(3, 6, 1)
  );

  @include test('should sort in ascending order') {    
    $actual: _pluck(_sort-by($maps, test-sort-by-2), 'b');

    @include assert-true(test-lists-equal($actual, 1 2 3 4));
  }
  @include test('should perform a stable sort') {
    $actual: _sort-by($stable-order, test-sort-by-3);

    @include assert-true(test-lists-equal($actual, $stable-order));
  }
  @include test('should use _identity when iteratee is nullish') {
    $list: 3 2 1;

    @include assert-true(test-lists-equal(_sort-by($list), 1 2 3));
  }
  @include test('should use _identity when iteratee is nullish') {
    $list: 3 2 1;

    @include assert-true(test-lists-equal(_sort-by($list, null), 1 2 3));
  }

    $list: null 4 1 null 3 null 2;

    // @include assert-true(test-lists-equal(_sort-by($list), 1 2 3 4 null null null),
    //   'should move null values to the end');

  @include test('should work with a _pluck style iteratee') {
    @include assert-true(test-lists-equal(_pluck(_sort-by($maps, 'b'), 'b'), (1 2 3 4)));
  }
  @include test('should work with a map for collection') {
    @include assert-true(test-lists-equal(_sort-by(('a': 3, 'b': 1, 'c': 2)), 1 2 3));
  }
  @include test('should treat number values for collection as empty') {
    @include assert-true(test-lists-equal(_sort-by(1), ()));
  }
  @include test('should work as an iteratee for _map') {
    $actual: _map((2 1 3, 3 2 1), _sort-by);

    @include assert-true(test-lists-equal($actual, (1 2 3, 1 2 3)));
  }
    // @include assert-equal(
    //   _sort-by-all($maps, 'a' 'b'),
    //   nth($maps, 3) nth($maps, 1) nth($maps, 4) nth($maps, 2),
    //   '_sort-by-all should sort multiple properties in ascending order');

  @include test('_sort-by-all should perform a stable sort') {
    @include assert-true(test-lists-equal(_sort-by-all($stable-order, 'a' 'c'), $stable-order));
  }

  @include test('should work with native functions') {
    @include assert-equal(_sort-by(black white yellow purple, lightness), black purple yellow white);
  }
}

// @include test-module('Sassdash') {
//   @include test('_sorted-index') {
//      // todo
//   }
// }

@include test-module('_starts-with') {
  $string: 'abc';

  @include test('should return true if a string starts with target') {
    @include assert-equal(_starts-with($string, 'a'), true);
  }

  @include test('should return false if a string does not start with target') {
    @include assert-equal(_starts-with($string, 'b'), false);
  }

  @include test('should work with a position argument') {
    @include assert-equal(_starts-with($string, 'b', 2), true);
  }

  @include test('should work with position >= string length') {
    @include assert-equal(_starts-with($string, 'a', 4), false);
  }

  @include test('should treat falsey position values as 1') {
    @each $value in $test-falsey {
      @include assert-equal(_starts-with($string, 'a', $value), true);
    }
  }

  @include test('should treat a negative position as 1') {
    @include assert-equal(_starts-with($string, 'a', -1), true);
  }

  @each $position in -9999, -3, -1, 0, 1, 2, 3, 5 {
    @include test('should return true when target is an empty string regardless of position') {
      @include assert-equal(_starts-with($string, '', $position), true);
    }
  }
}

@include test-module('_starts-with-any') {
  @include test('should work with a list for target') {
    @include assert-equal(_starts-with-any('abc', 'e' 'a' 'q'), true);
    @include assert-equal(_starts-with-any('abc', 'ac' 'abz' 'b'), false);
  } 
}

@include test-module('Sassdash') {
  @include test('_trunc') {
    $string: 'hi-diddly-ho there, neighborino';

    @include assert-equal(_trunc($string), 'hi-diddly-ho there, neighbo...',
      'should truncate to a length of 30 by default');

    @include assert-equal(_trunc($string, str-length($string)), $string,
      'should not truncate if string is <= length');

    @include assert-equal(_trunc($string, str-length($string) + 2), $string,
      'should not truncate if string is <= length');

    @include assert-equal(_trunc($string, 24), 'hi-diddly-ho there, n...',
      'should truncate string the given length');

    @include assert-equal(_trunc($string, ('omission': ' [...]')), 'hi-diddly-ho there, neig [...]',
      'should support an omission option');

    @include assert-equal(_trunc($string, $omission: ' [...]'), 'hi-diddly-ho there, neig [...]',
      'should support a named param omission option');

    @include assert-equal(_trunc($string, ('length': 4)), 'h...',
      'should support a length option');

    @include assert-equal(_trunc($string, $length: 4), 'h...',
      'should support a named param length option');

    @include assert-equal(_trunc($string, ('length': 24, 'separator': ' ')), 'hi-diddly-ho there,...',
      'should support a separator option');

    @include assert-equal(_trunc($string, $length: 24, $separator: ' '), 'hi-diddly-ho there,...',
      'should support a named param separator option');

    @include assert-equal(_trunc($string, 0), '...',
      'should handle zero length correctly');

    @include assert-equal(_trunc($string, -3), '...',
      'should treat negative length as 0');

    @include assert-equal(_trunc($string, '4'), 'h...',
      'should coerce length to an integer');

    @include assert-equal(_trunc(12345, '4'), '1...',
      'should coerce string to a string');

    $truncated: 'hi-diddly-ho there, neighbo...';

    @include assert-equal(_map($string $string $string, _trunc), $truncated $truncated $truncated,
      'should work as an iteratee for _map');
  }
}

@include test-module('Sassdash') {
  @include test('_times') {
    @include assert-equal(_times(3, null), 1 2 3,
      'should use _identity when iteratee is nullish');

    @include assert-equal(_times(3), 1 2 3,
      'should use _identity when iteratee is nullish');

    @include assert-equal(_times(3, test-square), 1 4 9,
      'should return a list of the results of each iteratee execution');

    @each $value in $test-falsey {
      @include assert-equal(_times($value), (),
        'should return an empty list for falsey and negative n arguments');
    }

    @include assert-equal(_times(-1), (),
      'should return an empty list for falsey and negative n arguments');

    @include assert-equal(_(3, times), 1 2 3,
      'should be chainable');
  }
}

@include test-module('_to-list') {
    $map: ('a': 1, 'b': 2, 'c': 3);
    $list: 1 2 3;

  @include test('should return the values of maps') {
    @include assert-true(test-lists-equal(_to-list($map), $list));
  }

  @include test('should work with a string for collection') {
    @include assert-true(test-lists-equal(_to-list('abc'), 'a' 'b' 'c'));
  }
}

@include test-module('Sassdash') {
  @include test('_trim methods') {
    @each $method-name in 'trim', 'trim-left', 'trim-right' {
      $func: unquote('_#{$method-name}');
      $is-trim-right: $method-name == 'trim-right';
      $is-trim-left: $method-name == 'trim-left';

      $parts: ();
      $parts: if($method-name != 'trim-right', append($parts, 'leading'), $parts);
      $parts: if($method-name != 'trim-left', append($parts, 'trailing'), $parts);
      $parts: _list-join($parts, ' and ');

      $string: ' a b c ';
      $expected: if($is-trim-right, ' ', '') + 'a b c' + if($is-trim-left, ' ', '');

      @include assert-equal(_call($func, null, $string), $expected,
        '#{$func} should remove #{$parts} whitespace');

      @include assert-equal(_call($func, null, 123), '123',
        '#{$func} should coerce string to a string');

      $string: '-_-a-b-c-_-';
      $expected: if($is-trim-right, '-_-', '') + 'a-b-c' + if($is-trim-left, '-_-', '');

      @include assert-equal(_call($func, null, $string, '_-'), $expected,
        '#{$func} should remove #{$parts} chars');

      $string: '121a-b-c121';
      $expected: if($is-trim-right, '121', '') + 'a-b-c' + if($is-trim-left, '121', '');

      @include assert-equal(_call($func, null, $string, 12), $expected,
        '#{$func} should coerce chars to a string');

      @each $value in null, '' {
        @include assert-equal(_call($func, null, $value, '_-'), '',
          '#{$func} should return an empty string when provided null or empty string and chars');

        @include assert-equal(_call($func, null, $value, null), '',
          '#{$func} should return an empty string when provided null or empty string and chars');

        @include assert-equal(_call($func, null, $value, ''), '',
          '#{$func} should return an empty string when provided null or empty string and chars');
      }

      $string: ' abc ';
      $expected: if($is-trim-right, ' ', '') + 'abc' + if($is-trim-left, ' ', '');

      @include assert-equal(_call($func, null, $string, null), $expected,
        '#{$func} should work with null or empty string for chars');

      @include assert-equal(_call($func, null, $string, ''), $string,
        '#{$func} should work with null or empty string for chars');

      $string: ' a b c ';
      $expected: if($is-trim-right, ' ', '') + 'a b c' + if($is-trim-left, ' ', '');

      $actual: _map($string $string $string, $func);

      @include assert-equal($actual, $expected $expected $expected,
        '#{$func} should work as an iteratee for _map');
    }
  }
}

@include test-module('Sassdash') {
  @include test('_unescape') {
    $escaped: '&amp;&lt;&gt;&quot;&#39;&#96;\/';
    $unescaped: '&<>"' + "'`/";

    $escaped: $escaped + $escaped;
    $unescaped: $unescaped + $unescaped;

    @include assert-equal(_unescape('&amp;lt;'), '&lt;',
      'should unescape entities in the correct order');

    @include assert-equal(_unescape($escaped), $unescaped,
      'should unescape the proper entities');

    @include assert-equal(_unescape('abc'), 'abc',
      'should handle strings with nothing to unescape');

    @include assert-equal(_unescape(_escape($unescaped)), $unescaped,
      'should unescape the same characters escaped by _escape');
    
  }
}

@include test-module('Sassdash') {
  @include test('_union') {
    $args: test-args(1, 2, 3);

    @include assert-true(test-lists-equal(_union(1 3 2, 5 2 1 4, 2 1), 1 3 2 5 4),
      'should return the union of the given lists');

    @include assert-true(test-lists-equal(_union(1 3 2, 1 (5,), 2 (4,)), 1 3 2 (5,) (4,)),
      'should not flatten nested lists');

    $list: (0,);

    @include assert-true(test-lists-equal(_union($list, 3, null, ('0': 1)), $list),
      'should ignore values that are not lists or arguments objects');

    @include assert-true(test-lists-equal(_union(null, $list, null, 2 1), 0 2 1),
      'should ignore values that are not lists or arguments objects');

    @include assert-true(test-lists-equal(_union(null, $list, null, $args), 0 1 2 3),
      'should ignore values that are not lists or arguments objects');
  }
}

@function test-uniq-1($map, $args...) {
  @return __get($map, 'a');
}
@include test-module('Sassdash') {
  @include test('_uniq') {
    $maps: (
      ( 'a': 2 ),
      ( 'a': 3 ),
      ( 'a': 1 ),
      ( 'a': 2 ),
      ( 'a': 3 ),
      ( 'a': 1 )
    );

    @include assert-true(test-lists-equal(_uniq(2 3 1 2 3 1), 2 3 1),
      'should return unique values of an unsorted list');

    @include assert-true(test-lists-equal(_uniq(1 1 2 2 3), 1 2 3),
      'should return unique values of a sorted list');

    @include assert-true(test-lists-equal(_uniq($maps, test-uniq-1), _slice($maps, 0, 3)),
      'should work with an iteratee argument without specifying is-sorted');

    @include assert-true(test-lists-equal(_uniq($maps, 'a'), _slice($maps, 0, 3)),
      'should work with a _pluck style iteratee');

    $lists: (2 1, 3 1, 1 1, 2 1, 3 1, 1 1);

    @include assert-true(test-lists-equal(_uniq($lists, 1), _slice($lists, 0, 3)),
      'should work with a _pluck style iteratee');

    $list: (2 1 2, 1 2 1);

    @include assert-true(test-lists-equal(_map($list, _uniq), (2 1, 1 2)),
      'should perform an unsorted uniq when used as an iteratee for _map');

    @include assert-true(test-lists-equal(_uniq('2' 2 3 '2' 3 2), '2' 2 3),
      'should distinguish between numbers and numeric strings');

    @include assert-equal(_unique(2 3 1 2), _uniq(2 3 1 2),
      'should be aliased');
  }
}

@include test-module('Sassdash') {
  @include test('_unique-id') {
    $actual: _times(500, _unique-id);

    @include assert-equal(length(_uniq($actual)), length($actual),
      'should generate unique ids');

    $actual: _unique-id('test-');

    @include assert-equal(_starts-with($actual, 'test-'), true,
      'should prepend prefix to unique id if specified');
  }
}

@include test-module('Sassdash') {
  @include test('_values') {
    $map: ('a': 1, 'b': 2);

    @include assert-equal(_values($map), 1 2,
      'should get the values of a map');
  }
}

@include test-module('Sassdash') {
  @include test('_where') {
    $maps: (
      ( 'a': 1 ),
      ( 'a': 1 ),
      ( 'a': 1, 'b': 2 ),
      ( 'a': 2, 'b': 2 ),
      ( 'a': 3 )
    );

    $pairs: (
      (( 'a': 1 ), (( 'a': 1 ), ( 'a': 1 ), ( 'a': 1, 'b': 2 ))),
      (( 'a': 2 ), (( 'a': 2, 'b': 2 ),)),
      (( 'a': 3 ), (( 'a': 3 ),)),
      (( 'b': 1 ), ()),
      (( 'b': 2 ), (( 'a': 1, 'b': 2 ), ( 'a': 2, 'b': 2 ))),
      (( 'a': 1, 'b': 2 ), (( 'a': 1, 'b': 2 ),))
    );

    @each $pair in $pairs {
      $actual: _where($maps, nth($pair, 1));

      @include assert-true(test-lists-equal($actual, nth($pair, 2)),
        'should filter by source properties');
    }

    $map: (
      'x': ( 'a': 1 ),
      'y': ( 'a': 3 ),
      'z': ( 'a': 1, 'b': 2 )
    );

    @include assert-equal(_where($map, ('a': 1)), __get($map, 'x') __get($map, 'z'),
      'should work with a map for collection');

    $list: (
      ('a': 1),
      ('a': 3),
      ('a': 1, 'b': 2)
    );

    $actual: _($list, where ('a': 1));

    @include assert-equal($actual, nth($list, 1) nth($list, 3),
      'should work in a lazy chain sequence');
  }
}

@include test-module('Sassdash') {
  @include test('_without') {
    @include assert-equal(_without(1 2 3 1 2 3, 1, 2), 3 3,
      'should remove all occurences of each value from a list');
  }
}

@include test-module('Sassdash') {
  @include test('_words') {
    @include assert-true(test-lists-equal(_map('a' 'b' 'c', _words), ('a',) ('b',) ('c',)),
      'should work as an iteratee for map');

    @include assert-true(test-lists-equal(_words('LETTERSAeiouAreVowels'), 'LETTERS' 'Aeiou' 'Are' 'Vowels'),
      'should work with compound words');
    @include assert-true(test-lists-equal(_words('aeiouAreVowels'), 'aeiou' 'Are' 'Vowels'),
      'should work with compound words');
    @include assert-true(test-lists-equal(_words('aeiou2Consonants'), 'aeiou' '2' 'Consonants'),
      'should work with compound words');
  }
}

@include test-module('Sassdash') {
  @include test('_xor') {
    @include assert-true(test-lists-equal(_xor(1 2 5, 2 3 5, 3 4 5), 1 4 5),
      'should return the symmetric difference of the given lists');

    @include assert-true(test-lists-equal(_xor(1 1 2 5, 2 2 3 5, 3 4 5 5), 1 4 5),
      'should return a list of unique values');

    @include assert-true(test-lists-equal(_xor(1 1), (1,)),
      'should return a list of unique values');

    $list: 1 2;

    @include assert-true(test-lists-equal(_xor((0,), 3, null, (1: 2)), (0,)),
      'should ignore individual secondary arguments');

    @include assert-true(test-lists-equal(_xor($list, 3, null, (1: 2)), $list),
      'should ignore values that are not lists or arguments objects');

    @include assert-true(test-lists-equal(_xor(null, $list, null, 2 3), 1 3),
      'should ignore values that are not lists or arglists');

    @include assert-true(test-lists-equal(_xor(null, $list, null, test-args(1, 2, 3)), (3,)),
      'should ignore values that are not lists or arglists');

    @include assert-true(test-lists-equal(_(1 2 3, xor (5 2 1 4)), 3 5 4),
      'should be chainable');
  }
}

@include test-module('Sassdash') {
  @include test('_zip methods') {
    @each $method-name in 'unzip', 'zip' {
      $func: unquote('_#{$method-name}');
      $is-zip: $method-name == 'zip';

      $map: (
        'an empty array': (
          (),
          ()
        ),
        '0-tuples': (
          ((), ()),
          ()
        ),
        '2-tuples': (
          (('barney', 'fred'), (36, 40)),
          (('barney', 36), ('fred', 40))
        ),
        '3-tuples': (
          (('barney', 'fred'), (36, 40), (true, false)),
          (('barney', 36, true), ('fred', 40, false))
        )
      );

      @each $key, $pair in $map {
        $lists: if($is-zip, nth($pair, 1), nth($pair, 2));
        $actual: if($is-zip, _call($func, null, $lists...), _call($func, null, $lists));
        $expected: if($is-zip, nth($pair, 2), if(length($actual) == 0, (), nth($pair, 1)));

        @include assert-true(test-lists-equal($actual, $expected),
          '#{$func} should work with #{$key}');
      }
    }
  }
}

@function test-zip-map-1($value, $args...) {
  @return __parse-float($value) > 1;
}

@include test-module('Sassdash') {
  @include test('_zip-map') {
    $map: ('barney': 36, 'fred': 40);
    $list: (('barney', 36), ('fred', 40));

    $actual: _zip-map('barney' 'fred', 36 40);
    @include assert-equal($actual, $map,
      'should zip together key/value lists into a map');

    @include assert-equal(_zip-map(('a',), 1 2), ('a': 1),
      'should ignore extra values');

    @include assert-equal(_zip-map($list), $map,
      'should accept a two dimensional list');

    @include assert-equal(_zip-map('barney' 'fred'), ('barney': null, 'fred': null),
      'should not assume keys is two dimensional if values argument is not provided');

    @each $value in $test-falsey {
      @include assert-equal(_zip-map($value), (),
        'should accept a falsey list argument');
    }

    @include assert-equal(_zip-map(_pairs($map)), $map,
      'should support consuming the return value of _pairs');

    $list: ('a' 1, 'b' 2);
    $predicate: test-zip-map-1;
    $actual: _($list, zip-map, map _to-string, filter $predicate, take);

    @include assert-true(test-lists-equal($actual, ('2',)),
      'should work in a lazy chain sequence');

    @include assert-equal(_object($list), _zip-map($list),
      'should be aliased');
  }
}

@include test-module('Sassdash') {
  @include test('_concat') {
    @include assert-equal(_concat(1 2, 3 4), 1 2 3 4,
      'should concat two lists to one');

    @include assert-equal(_concat(1 2, 3 4, 5 6), 1 2 3 4 5 6,
      'should concat multiple lists to one');

    @include assert-equal(_concat(1, 2 3), 1 2 3,
      'should support non-list source');

    @include assert-equal(_concat(1 2, 3, 4), 1 2 3 4,
      'should support non-list arguments');

    @include assert-equal(_concat(1, 2), 1 2,
      'should support non-list source nor arguments');

    @include assert-equal(_concat(1 2), 1 2,
      'should support no arguments other than source');

    @include assert-equal(_concat(1), (1,),
      'should return a list');
  }
}

@include test-module('_str-concat') {
    @include test('should concatenate strings') {
        @include assert-equal(_str-concat('hello', ' world'), 'hello world');
    }

    @include test('should concatenate multiple strings') {
        @include assert-equal(_str-concat('one', 'two', 'three'), 'onetwothree');
    }

    @include test('should coerce arguments to strings') {
        @include assert-equal(_str-concat('one', 2, 3), 'one23');
        @include assert-equal(_str-concat(1, 2, 3, 4, 5), '12345');
    }

    @include test('should return an empty string when provided no arguments') {
        @include assert-equal(_str-concat(), '');
    }

    @include test('should return initial source when provided no extra arguments') {
        @include assert-equal(_str-concat('foo'), 'foo');
    }

    @include test('should work as iteratee for _reduce') {
        $list: ('a', 'b', 'c', 'd', 'e');

        @include assert-equal(_reduce($list, _str-concat), 'abcde');
    }
}

@include test-module('Sassdash') {
  $list: 'a' 'b' 'c' 'd' 'e';
  $list-list: ('a' 'b' 'c', 'd' 'e' 'f', 'g' 'h' 'i');

  @include test('should join a list to a string') {
    @include assert-equal(_join($list), 'abcde');
  }

  @include test('should accept a custom separator') {
    @include assert-equal(_join($list, ','), 'a,b,c,d,e');

  }

  @include test('should accept a custom separator greater than 1 character') {
    @include assert-equal(_join($list, '--'), 'a--b--c--d--e');
  }

  @include test('should default to native join() behavior if separator argument is a list') {
    @include assert-equal(_join($list, $list), 'a' 'b' 'c' 'd' 'e' 'a' 'b' 'c' 'd' 'e');
  }

  @include test('should support single-item lists') {
    @include assert-equal(_join(('a',), ','), 'a');
  }

  $actual: _map($list-list, _join);
  $expected: ('abc' 'def' 'ghi');

  @include test('should work as iteratee for _map') {
    @include assert-equal($actual, $expected);
  }

  @include test('should be chainable') {
    @include assert-equal(_($list-list,
        map _join,
        reduce _str-concat,
        concat 'jkl',
        join ' -- '),
      'abcdefghi -- jkl');
  }
}

@include test-module('Sassdash') {
  @include test('_reverse') {
    $list: 1 2 3;
    $list-list: 1 2 3, 4 5 6;

    @include assert-equal(_reverse('abcde'), 'edcba',
      'should reverse a string');

    @include assert-equal(_reverse($list), 3 2 1,
      'should reverse a list');

    @include assert-equal(_map($list-list, _reverse), ((3 2 1) (6 5 4)),
      'should work as iteratee for _map');

    @include assert-equal(
      _($list-list, map _join, map _to-string, reduce _str-concat, reverse),
      '654321',
      'should be chainable');
  }
}

@include test-module('Sassdash') {
  @include test('_to-string') {
    @include assert-equal(_to-string('abc'), 'abc',
      'should not affect string as string argument');

    @include assert-equal(_to-string(123), '123',
      'should coerce number to string');

    @include assert-equal(_to-string(true), 'true',
      'should coerce bool to string');

    @include assert-equal(_to-string(1 2 3), '1 2 3',
      'should coerce list to string');

    @include assert-equal(_to-string(('a': 1, 'b': 2, 'c': 3)), '("a": 1, "b": 2, "c": 3)',
      'should coerce map to string');
  }
}

@include test-module('native functions') {
    @include test('should only pass a single argument to native functions used as iteratees') {
        @include assert-equal(_map(1.23 4.56 7.89, floor), 1 4 7);
    }
}

@include report;